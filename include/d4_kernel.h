#ifndef GPUSAT_D4_KERNEL_H
#define GPUSAT_D4_KERNEL_H

#include <string>

std::string inc_kernel("#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
                               "#define stype double\n"
                               "//#define __global\n"
                               "//#define __kernel\n"
                               "\n"
                               "typedef struct {\n"
                               "    stype x[4];\n"
                               "} d4_Type;\n"
                               "\n"
                               "void d4_mul(__global d4_Type *a, __global d4_Type *b, d4_Type *ret);\n"
                               "\n"
                               "void d4_mul_l(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                               "\n"
                               "void d4_mul_w(d4_Type *a, __global d4_Type *b, d4_Type *ret);\n"
                               "\n"
                               "void d4_add(__global d4_Type *a, __global d4_Type *b, __global d4_Type *ret);\n"
                               "\n"
                               "void d4_add1(d4_Type *a, __global d4_Type *b, d4_Type *ret);\n"
                               "\n"
                               "void d4_add2(__global d4_Type *a, d4_Type *b, __global d4_Type *ret);\n"
                               "\n"
                               "void d4_add_(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                               "\n"
                               "void d4_div(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                               "\n"
                               "void d4_assign(d4_Type *a, d4_Type *b);\n"
                               "\n"
                               "void d4_assign_(__global d4_Type *a, d4_Type *b);\n"
                               "\n"
                               "void new_d4(stype d, stype d1, stype d2, stype d3, d4_Type *ret);\n"
                               "\n"
                               "void new_d4_(stype d, stype d1, stype d2, stype d3, __global d4_Type *ret);\n"
                               "\n"
                               "int isNotSat(unsigned long assignment, __global long *clause, __global unsigned long *variables);\n"
                               "\n"
                               "void to_d4(stype x, d4_Type *ret);\n"
                               "\n"
                               "/**\n"
                               " * Operation to solve a Join node in the decomposition.\n"
                               " *\n"
                               " * @param nSol\n"
                               " *      array containing the number of solutions for each assignment for the current node\n"
                               " * @param e1Sol\n"
                               " *      array containing the number of solutions for each assignment for the first edge\n"
                               " * @param e2Sol\n"
                               " *      array containing the number of solutions for each assignment for the second edge\n"
                               " * @param minIDe1\n"
                               " *      min id of the first edge\n"
                               " * @param maxIDe1\n"
                               " *      max id of the first edge\n"
                               " * @param minIDe2\n"
                               " *      min id of the second edge\n"
                               " * @param maxIDe2\n"
                               " *      max id of the second edge\n"
                               " * @param startIDn\n"
                               " *      start id of the current node\n"
                               " * @param startIDe1\n"
                               " *      start id of the first edge\n"
                               " * @param startIDe2\n"
                               " *      of the second edge\n"
                               " * @param numClauses\n"
                               " *      number of clauses in the current node\n"
                               " */\n"
                               "__kernel void solveJoin(__global d4_Type *nSol, __global d4_Type *e1Sol, __global d4_Type *e2Sol,\n"
                               "                        unsigned long minIDe1, unsigned long maxIDe1,\n"
                               "                        unsigned long minIDe2, unsigned long maxIDe2,\n"
                               "                        unsigned long startIDn, unsigned long startIDe1, unsigned long startIDe2,\n"
                               "                        unsigned long numClauses,\n"
                               "                        __global d4_Type *weights, __global unsigned long *nVars, __global int *sols) {\n"
                               "    unsigned long combinations = ((unsigned long) exp2((double) numClauses));\n"
                               "    unsigned long start2 = 0, end2 = combinations - 1;\n"
                               "\n"
                               "    unsigned long id = get_global_id(0);\n"
                               "    unsigned long mask = id & (((unsigned long) exp2((double) numClauses)) - 1);\n"
                               "    unsigned long templateID = id >> numClauses << numClauses;\n"
                               "    d4_Type tmpSol;\n"
                               "    new_d4(0.0,0.0,0.0,0.0,&tmpSol);\n"
                               "    //sum up the solution count for all subsets of Clauses (A1,A2) where the intersection of A1 and A2 = A\n"
                               "    for (; start2 < (combinations - 1) && e2Sol[(templateID | start2) - (startIDe2)].x[0] == 0; start2++);\n"
                               "    for (; end2 > 0 && e2Sol[(templateID | end2) - (startIDe2)].x[0] == 0; end2--);\n"
                               "    for (int a = 0; a < combinations; a++) {\n"
                               "        if ((templateID | a) >= minIDe1 && (templateID | a) < maxIDe1 && e1Sol[(templateID | a) - (startIDe1)].x[0] != 0) {\n"
                               "            for (int b = start2; b <= end2; b++) {\n"
                               "                if (((a | b)) == mask && ((templateID | b) >= minIDe2 && (templateID | b) < maxIDe2) && e2Sol[(templateID | b) - (startIDe2)].x[0] != 0) {\n"
                               "                    d4_Type mul;\n"
                               "                    d4_mul(&e1Sol[(templateID | a) - (startIDe1)], &e2Sol[(templateID | b) - (startIDe2)], &mul);\n"
                               "                    d4_add_(&tmpSol, &mul, &tmpSol);\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    if (tmpSol.x[0] != 0.0) {\n"
                               "        if (weights != 0) {\n"
                               "            d4_Type weight;\n"
                               "            new_d4(1.0,0.0,0.0,0.0,&weight);\n"
                               "            unsigned long assignment = id >> numClauses;\n"
                               "            for (int a = 0; nVars[a] != 0; a++) {\n"
                               "                d4_mul_w(&weight, &weights[((assignment >> a) & 1) > 0 ? nVars[a] * 2 : nVars[a] * 2 + 1], &weight);\n"
                               "            }\n"
                               "            d4_div(&tmpSol, &weight, &weight);\n"
                               "            d4_add2(&nSol[id - (startIDn)], &weight, &nSol[id - (startIDn)]);\n"
                               "        } else {\n"
                               "            d4_add2(&nSol[id - (startIDn)], &tmpSol, &nSol[id - (startIDn)]);\n"
                               "        }\n"
                               "    }\n"
                               "    if (nSol[id - (startIDn)].x[0] > 0) {\n"
                               "        *sols = 1;\n"
                               "    }\n"
                               "}\n"
                               "\n"
                               "/**\n"
                               " * Operation to solve a Introduce node in the decomposition.\n"
                               " *\n"
                               " * @param nSol\n"
                               " *      array containing the number of solutions for each assignment for the current node\n"
                               " * @param eSol\n"
                               " *      array containing the number of solutions for each assignment for the edge\n"
                               " * @param clauses\n"
                               " *      array containing the clauses of the current node, negated atoms are negative\n"
                               " * @param cLen\n"
                               " *      length of the clauses array\n"
                               " * @param nVars\n"
                               " *      array containing the ids of the variables in the current node\n"
                               " * @param eVars\n"
                               " *      array containing the ids of the variables in the edge\n"
                               " * @param numNV\n"
                               " *      number of variables in the current node\n"
                               " * @param numEV\n"
                               " *      number of variables in the edge\n"
                               " * @param nClauses\n"
                               " *      array containing the clause ids of the current node\n"
                               " * @param eClauses\n"
                               " *      array containing the clause ids of the edge\n"
                               " * @param numNC\n"
                               " *      number of clauses in the current node\n"
                               " * @param numEC\n"
                               " *      number of clauses in the edge\n"
                               " * @param startIDn\n"
                               " *      start id of the current node\n"
                               " * @param startIDe\n"
                               " *      start id of the edge\n"
                               " * @param minID\n"
                               " *      min id of the edge\n"
                               " * @param maxID\n"
                               " *      max id of the edge\n"
                               " */\n"
                               "__kernel void solveIntroduce(__global d4_Type *nSol, __global d4_Type *eSol,\n"
                               "                             __global long *clauses, unsigned long cLen,\n"
                               "                             __global unsigned long *nVars, __global unsigned long *eVars,\n"
                               "                             unsigned long numNV, unsigned long numEV,\n"
                               "                             __global unsigned long *nClauses, __global unsigned long *eClauses,\n"
                               "                             unsigned long numNC, unsigned long numEC,\n"
                               "                             unsigned long startIDn, unsigned long startIDe,\n"
                               "                             unsigned long minIDe, unsigned long maxIDe, __global d4_Type *weights, __global int *sols) {\n"
                               "    unsigned long id = get_global_id(0);\n"
                               "    unsigned long assignment = id >> numNC, templateID = 0;\n"
                               "    unsigned long a = 0, b = 0, c = 0, i = 0, notSAT = 0, base = 0;\n"
                               "    //check clauses\n"
                               "    for (a = 0, b = 0, i = 0; a < numNC; i++) {\n"
                               "        if (i == 0 || clauses[i] == 0) {\n"
                               "            if (clauses[i] == 0) i++;\n"
                               "            if (nClauses[a] == eClauses[b]) {\n"
                               "                b++;\n"
                               "            } else if (isNotSat(assignment, &clauses[i], nVars) == ((id >> a) & 1)) {\n"
                               "                new_d4_(0.0,0.0,0.0,0.0,&nSol[id - startIDn]);\n"
                               "                return;\n"
                               "            }\n"
                               "            a++;\n"
                               "        }\n"
                               "    }\n"
                               "    unsigned long d = 0;\n"
                               "    int baseSum = 0;\n"
                               "    //check variables\n"
                               "    for (i = 0, c = 0; i < cLen; i++) {\n"
                               "        if (clauses[i] == 0) {\n"
                               "            baseSum = 0;\n"
                               "            if (nClauses[c] == eClauses[d]) {\n"
                               "                d++;\n"
                               "            }\n"
                               "            c++;\n"
                               "        } else {\n"
                               "            for (a = 0; a < numNV; a++) {\n"
                               "                if ((((id >> c) & 1) == 0) && (clauses[i] == nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                    new_d4_(0.0,0.0,0.0,0.0,&nSol[id - startIDn]);\n"
                               "                    return;\n"
                               "                }\n"
                               "                if ((baseSum == 0) && (nClauses[c] == eClauses[d]) && (((id >> c) & 1) == 1) &&\n"
                               "                    (clauses[i] == nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                    base++;\n"
                               "                    baseSum = 1;\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    //generate template variables\n"
                               "    for (b = 0, a = 0; a < numNV; a++) {\n"
                               "        if (nVars[a] == eVars[b]) {\n"
                               "            templateID |= ((id >> (a + numNC)) & 1) << (b + numEC);\n"
                               "            b++;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    //generate template clauses\n"
                               "    for (b = 0, a = 0; a < numNC; a++) {\n"
                               "        if (nClauses[a] == eClauses[b]) {\n"
                               "            templateID |= ((id >> a) & 1) << b;\n"
                               "            b++;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    unsigned long combinations = (unsigned long) exp2((double) base);\n"
                               "    unsigned long otherID = templateID, nc = 0, ec = 0, x = 0, index = 0, rec;\n"
                               "\n"
                               "    d4_Type weight;\n"
                               "    new_d4(1.0,0.0,0.0,0.0,&weight);\n"
                               "\n"
                               "    if (weights != 0) {\n"
                               "        for (b = 0, a = 0; nVars[a] != 0; a++) {\n"
                               "            if ((nVars[a] != eVars[b])) {\n"
                               "                d4_mul_w(&weight, &weights[((assignment >> a) & 1) > 0 ? nVars[a] * 2 : nVars[a] * 2 + 1], &weight);\n"
                               "            }\n"
                               "            if (nVars[a] == eVars[b] && eVars[b] != 0) {\n"
                               "                b++;\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    d4_Type tmp;\n"
                               "    new_d4(0.0,0.0,0.0,0.0,&tmp);\n"
                               "    if (numNV != numEV) {\n"
                               "        for (i = 0, c = 0; i < combinations; i++) {\n"
                               "            otherID = templateID;\n"
                               "            index = 0;\n"
                               "\n"
                               "            for (ec = 0, nc = 0, x = 0; nc < numNC; nc++, x++) {\n"
                               "                rec = 0;\n"
                               "                if (eClauses[ec] == nClauses[nc]) {\n"
                               "                    for (; clauses[x] != 0; x++) {\n"
                               "                        for (a = 0, b = 0; a < numNV && rec == 0; a++) {\n"
                               "                            if (clauses[x] == (nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                                otherID &= ~(((i >> index) & 1) << ec);\n"
                               "                                index++;\n"
                               "                                rec = 1;\n"
                               "                            }\n"
                               "                            if (nVars[a] == eVars[b]) {\n"
                               "                                b++;\n"
                               "                            } else {\n"
                               "                            }\n"
                               "                        }\n"
                               "                    }\n"
                               "                    ec++;\n"
                               "                } else {\n"
                               "                    for (; clauses[x] != 0; x++);\n"
                               "                }\n"
                               "            }\n"
                               "\n"
                               "            if (otherID >= (minIDe) && otherID < (maxIDe)) {\n"
                               "                d4_add1(&tmp, &eSol[otherID - (startIDe)], &tmp);\n"
                               "            }\n"
                               "        }\n"
                               "    } else {\n"
                               "        if (otherID >= (minIDe) && otherID < (maxIDe)) {\n"
                               "            d4_add1(&tmp, &eSol[otherID - (startIDe)], &tmp);\n"
                               "        }\n"
                               "    }\n"
                               "    d4_mul_l(&tmp, &weight, &tmp);\n"
                               "    d4_add2(&nSol[id - (startIDn)], &tmp, &nSol[id - (startIDn)]);\n"
                               "    if (nSol[id - (startIDn)].x[0] > 0) {\n"
                               "        *sols = 1;\n"
                               "    }\n"
                               "\n"
                               "}\n"
                               "\n"
                               "//check if Clause is not Satisfiable\n"
                               "int isNotSat(unsigned long assignment, __global long *clause, __global unsigned long *variables) {\n"
                               "    int a = 0, i = 0;\n"
                               "    for (a = 0; variables[a] != 0; a++) {\n"
                               "        for (i = 0; clause[i] != 0; i++) {\n"
                               "            if (clause[i] == variables[a] || clause[i] == -variables[a]) {\n"
                               "                if ((clause[i] > 0 && ((assignment >> a) & 1) == 1) ||\n"
                               "                    (clause[i] < 0 && ((assignment >> a) & 1) == 0)) {\n"
                               "                    return 0;\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    return 1;\n"
                               "}\n"
                               "\n"
                               "/**\n"
                               " * introduce function for the introduce forget operation\n"
                               " *\n"
                               " * @param nSol\n"
                               " *      array containing the number of solutions for each assignment for the current node\n"
                               " * @param eSol\n"
                               " *      array containing the number of solutions for each assignment for the edge\n"
                               " * @param clauses\n"
                               " *      array containing the clauses of the current node, negated atoms are negative\n"
                               " * @param cLen\n"
                               " *      length of the clauses array\n"
                               " * @param nVars\n"
                               " *      array containing the ids of the variables in the current node\n"
                               " * @param eVars\n"
                               " *      array containing the ids of the variables in the edge\n"
                               " * @param numNV\n"
                               " *      number of variables in the current node\n"
                               " * @param numEV\n"
                               " *      number of variables in the edge\n"
                               " * @param nClauses\n"
                               " *      array containing the clause ids of the current node\n"
                               " * @param eClauses\n"
                               " *      array containing the clause ids of the edge\n"
                               " * @param numNC\n"
                               " *      number of clauses in the current node\n"
                               " * @param numEC\n"
                               " *      number of clauses in the edge\n"
                               " * @param startIDe\n"
                               " *      start id of the edge\n"
                               " * @param minIDe\n"
                               " *      min id of the edge\n"
                               " * @param maxIDe\n"
                               " *      max id of the edge\n"
                               " */\n"
                               "d4_Type solveIntroduceF(__global d4_Type *eSol,\n"
                               "                        __global long *clauses, unsigned long cLen,\n"
                               "                        __global unsigned long *nVars, __global unsigned long *eVars,\n"
                               "                        unsigned long numNV, unsigned long numEV,\n"
                               "                        __global unsigned long *nClauses, __global unsigned long *eClauses,\n"
                               "                        unsigned long numNC, unsigned long numEC,\n"
                               "                        unsigned long startIDe,\n"
                               "                        unsigned long minIDe, unsigned long maxIDe, __global d4_Type *weights,\n"
                               "                        long id) {\n"
                               "    unsigned long assignment = id >> numNC, templateID = 0;\n"
                               "    unsigned long a = 0, b = 0, c = 0, i = 0, notSAT = 0, base = 0;\n"
                               "    //check clauses\n"
                               "    for (a = 0, b = 0, i = 0; a < numNC; i++) {\n"
                               "        if (i == 0 || clauses[i] == 0) {\n"
                               "            if (clauses[i] == 0) i++;\n"
                               "            if (nClauses[a] == eClauses[b]) {\n"
                               "                b++;\n"
                               "            } else if (isNotSat(assignment, &clauses[i], nVars) == ((id >> a) & 1)) {\n"
                               "                d4_Type tmp;\n"
                               "                new_d4(0.0,0.0,0.0,0.0,&tmp);\n"
                               "                return tmp;\n"
                               "            }\n"
                               "            a++;\n"
                               "        }\n"
                               "    }\n"
                               "    unsigned long d = 0;\n"
                               "    int baseSum = 0;\n"
                               "    //check variables\n"
                               "    for (i = 0, c = 0; i < cLen; i++) {\n"
                               "        if (clauses[i] == 0) {\n"
                               "            baseSum = 0;\n"
                               "            if (nClauses[c] == eClauses[d]) {\n"
                               "                d++;\n"
                               "            }\n"
                               "            c++;\n"
                               "        } else {\n"
                               "            for (a = 0; a < numNV; a++) {\n"
                               "                if ((((id >> c) & 1) == 0) && (clauses[i] == nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                    d4_Type tmp;\n"
                               "                    new_d4(0.0,0.0,0.0,0.0,&tmp);\n"
                               "                    return tmp;\n"
                               "                }\n"
                               "                if ((baseSum == 0) && (nClauses[c] == eClauses[d]) && (((id >> c) & 1) == 1) &&\n"
                               "                    (clauses[i] == nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                    base++;\n"
                               "                    baseSum = 1;\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    //template variables\n"
                               "    for (b = 0, a = 0; a < numNV; a++) {\n"
                               "        if (nVars[a] == eVars[b]) {\n"
                               "            templateID |= ((id >> (a + numNC)) & 1) << (b + numEC);\n"
                               "            b++;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    //template clauses\n"
                               "    for (b = 0, a = 0; a < numNC; a++) {\n"
                               "        if (nClauses[a] == eClauses[b]) {\n"
                               "            templateID |= ((id >> a) & 1) << b;\n"
                               "            b++;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    unsigned long combinations = (unsigned long) exp2((double) base);\n"
                               "    unsigned long otherID = templateID, nc = 0, ec = 0, x = 0, index = 0, rec;\n"
                               "\n"
                               "    d4_Type weight;\n"
                               "    new_d4(1.0,0.0,0.0,0.0,&weight);\n"
                               "\n"
                               "    if (weights != 0) {\n"
                               "        for (b = 0, a = 0; nVars[a] != 0; a++) {\n"
                               "            if ((nVars[a] != eVars[b])) {\n"
                               "                d4_mul_w(&weight, &weights[((assignment >> a) & 1) > 0 ? nVars[a] * 2 : nVars[a] * 2 + 1], &weight);\n"
                               "            }\n"
                               "            if (nVars[a] == eVars[b] && eVars[b] != 0) {\n"
                               "                b++;\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    d4_Type tmp;\n"
                               "    new_d4(0.0,0.0,0.0,0.0,&tmp);\n"
                               "    if (numNV != numEV) {\n"
                               "        for (i = 0, c = 0; i < combinations; i++) {\n"
                               "            otherID = templateID;\n"
                               "            index = 0;\n"
                               "\n"
                               "            for (ec = 0, nc = 0, x = 0; nc < numNC; nc++, x++) {\n"
                               "                rec = 0;\n"
                               "                if (eClauses[ec] == nClauses[nc]) {\n"
                               "                    for (; clauses[x] != 0; x++) {\n"
                               "                        for (a = 0, b = 0; a < numNV && rec == 0; a++) {\n"
                               "                            if (clauses[x] == (nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                                otherID &= ~(((i >> index) & 1) << ec);\n"
                               "                                index++;\n"
                               "                                rec = 1;\n"
                               "                            }\n"
                               "                            if (nVars[a] == eVars[b]) {\n"
                               "                                b++;\n"
                               "                            } else {\n"
                               "                            }\n"
                               "                        }\n"
                               "                    }\n"
                               "                    ec++;\n"
                               "                } else {\n"
                               "                    for (; clauses[x] != 0; x++);\n"
                               "                }\n"
                               "            }\n"
                               "\n"
                               "            if (otherID >= minIDe && otherID < maxIDe) {\n"
                               "                if (eSol != 0) {\n"
                               "                    d4_add1(&tmp, &eSol[otherID - startIDe], &tmp);\n"
                               "                } else {\n"
                               "                    d4_Type one;\n"
                               "                    new_d4(1.0,0.0,0.0,0.0,&one);\n"
                               "                    d4_add_(&tmp, &one, &tmp);\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    } else {\n"
                               "        if (otherID >= minIDe && otherID < maxIDe) {\n"
                               "            if (eSol != 0) {\n"
                               "                d4_add1(&tmp, &eSol[otherID - startIDe], &tmp);\n"
                               "            } else {\n"
                               "                d4_Type one;\n"
                               "                new_d4(1.0,0.0,0.0,0.0,&one);\n"
                               "                d4_add_(&tmp, &one, &tmp);\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    d4_mul_l(&tmp, &weight, &tmp);\n"
                               "    return tmp;\n"
                               "}\n"
                               "\n"
                               "/**\n"
                               " * combination of the introduce and forget operation\n"
                               " *\n"
                               " * @param solsF\n"
                               " *      array containing the number of solutions for each assignment for the current node\n"
                               " * @param solsE\n"
                               " *      array containing the number of solutions for each assignment for the edge\n"
                               " * @param varsF\n"
                               " *      array containing the ids of the variables in the current node\n"
                               " * @param varsE\n"
                               " *      array containing the ids of the variables in the edge node\n"
                               " * @param numVF\n"
                               " *      the number of variables in the current node\n"
                               " * @param numVE\n"
                               " *      the number of variables in the edge node\n"
                               " * @param fClauses\n"
                               " *      array containing the clause ids of the current node\n"
                               " * @param eClauses\n"
                               " *      array containing the clause ids of the edge node\n"
                               " * @param numCF\n"
                               " *      number of clauses in the current node\n"
                               " * @param numCE\n"
                               " *      number of clauses in the edge node\n"
                               " * @param startIDf\n"
                               " *      start id of the current node\n"
                               " * @param startIDe\n"
                               " *      start id of the edge node\n"
                               " * @param minIDE\n"
                               " *      min id of the edge\n"
                               " * @param maxIDE\n"
                               " *      max id of the edge\n"
                               " * @param sols\n"
                               " *      flag, indicating that there are solutions in the current bag\n"
                               " * @param varsI\n"
                               " *      array containing the ids of the variables in the introduce node\n"
                               " * @param numVI\n"
                               " *      array containing the number of variables in the introduce node\n"
                               " * @param iClauses\n"
                               " *      array containing the clause ids of the introduce node\n"
                               " * @param numCI\n"
                               " *      number of clauses in the introduce node\n"
                               " * @param clauses\n"
                               " *      array containing the clauses of the current node, negated atoms are negative\n"
                               " * @param cLen\n"
                               " *      length of the clauses array\n"
                               " * @param weights\n"
                               " *      array containing the weights of each variable\n"
                               " */\n"
                               "__kernel void solveIntroduceForget(__global d4_Type *solsF, __global d4_Type *solsE,\n"
                               "                                   __global unsigned long *varsF, __global unsigned long *varsE,\n"
                               "                                   unsigned long numVF, unsigned long numVE,\n"
                               "                                   __global unsigned long *fClauses, __global unsigned long *eClauses,\n"
                               "                                   unsigned long numCF, unsigned long numCE,\n"
                               "                                   unsigned long startIDf, unsigned long startIDe,\n"
                               "                                   unsigned long minIDE, unsigned long maxIDE, __global int *sols,\n"
                               "                                   __global unsigned long *varsI, unsigned long numVI, __global unsigned long *iClauses, unsigned long numCI,\n"
                               "                                   __global long *clauses, unsigned long cLen, __global d4_Type *weights) {\n"
                               "    unsigned long id = get_global_id(0);\n"
                               "    unsigned long a = 0, b = 0, templateId = 0, i = 0;\n"
                               "    unsigned long combinations = (unsigned long) exp2((double) numVI - numVF);\n"
                               "    if (numVI != numVF || numCI != numCF) {\n"
                               "        //generate template clauses\n"
                               "        for (a = 0, b = 0; a < numCI; a++) {\n"
                               "            if (fClauses[b] == iClauses[a]) {\n"
                               "                templateId = templateId | (((id >> b) & 1) << a);\n"
                               "                b++;\n"
                               "            } else {\n"
                               "                templateId = templateId | (1 << a);\n"
                               "            }\n"
                               "        }\n"
                               "        //generate template variables\n"
                               "        for (a = 0, b = 0; a < numVI && b < numVF; a++) {\n"
                               "            if (varsF[b] == varsI[a]) {\n"
                               "                templateId = templateId | (((id >> (b + numCF)) & 1) << (a + numCI));\n"
                               "                b++;\n"
                               "            }\n"
                               "        }\n"
                               "\n"
                               "        // iterate through all corresponding assignments in the edge\n"
                               "        for (i = 0; i < combinations; i++) {\n"
                               "            long b = 0, otherId = templateId;\n"
                               "            for (a = 0; a < numVI; a++) {\n"
                               "                if (b >= numVF || varsI[a] != varsF[b]) {\n"
                               "                    otherId = otherId | (((i >> (a - b)) & 1) << (a + numCI));\n"
                               "                } else {\n"
                               "                    b++;\n"
                               "                }\n"
                               "            }\n"
                               "            // get solution count from edge\n"
                               "            d4_Type tmp = solveIntroduceF(solsE, clauses, cLen, varsI, varsE, numVI, numVE, iClauses, eClauses, numCI, numCE, startIDe, minIDE, maxIDE,\n"
                               "                                          weights, otherId);\n"
                               "            d4_add2(&solsF[id - (startIDf)], &tmp, &solsF[id - (startIDf)]);\n"
                               "        }\n"
                               "    } else {\n"
                               "        // only solve introduce if there is no forget\n"
                               "        d4_Type tmp = solveIntroduceF(solsE, clauses, cLen, varsI, varsE, numVI, numVE, iClauses, eClauses, numCI, numCE, startIDe, minIDE, maxIDE,\n"
                               "                                      weights, id);\n"
                               "        d4_add2(&solsF[id - (startIDf)], &tmp, &solsF[id - (startIDf)]);\n"
                               "    }\n"
                               "    if (solsF[id - (startIDf)].x[0] > 0) {\n"
                               "        *sols = 1;\n"
                               "    }\n"
                               "}\n"
                               "\n"
                               "/**\n"
                               " * adaptation of https://github.com/scibuilder/QD for opencl\n"
                               " */\n"
                               "\n"
                               "///headers\n"
                               "#define _QD_SPLITTER 134217729.0 // = 2^27 + 1\n"
                               "#define _QD_SPLIT_THRESH 6.69692879491417e+299 // = 2^996\n"
                               "\n"
                               "void d4_neg(d4_Type *x, d4_Type *ret);\n"
                               "\n"
                               "void d4_minus(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                               "\n"
                               "void d4_log(d4_Type *a, d4_Type *ret);\n"
                               "\n"
                               "stype d4_quick_two_sum(stype a, stype b, stype *err);\n"
                               "\n"
                               "stype d4_two_sum(stype a, stype b, stype *err);\n"
                               "\n"
                               "stype d4_quick_three_accum(stype *a, stype *b, stype c);\n"
                               "\n"
                               "void d4_renorm(stype *c0, stype *c1, stype *c2, stype *c3);\n"
                               "\n"
                               "void d4_split(stype a, stype *hi, stype *lo);\n"
                               "\n"
                               "stype d4_two_prod(stype a, stype b, stype *err);\n"
                               "\n"
                               "void d4_three_sum(stype *a, stype *b, stype *c);\n"
                               "\n"
                               "void d4_renorm_(stype *c0, stype *c1, stype *c2, stype *c3, stype *c4);\n"
                               "\n"
                               "void d4_three_sum2(stype *a, stype *b, stype *c);;\n"
                               "\n"
                               "void d4_mul_qd_d(d4_Type *a, stype b, d4_Type *ret);\n"
                               "\n"
                               "void d4_ldexp(d4_Type *a, int n, d4_Type *ret);\n"
                               "\n"
                               "bool d4_is_zero(d4_Type *x);\n"
                               "\n"
                               "bool d4_is_one(d4_Type *x);\n"
                               "\n"
                               "void d4_mul_pwr2(d4_Type *a, stype b, d4_Type *ret);\n"
                               "\n"
                               "void d4_sqr(d4_Type *a, d4_Type *ret);\n"
                               "\n"
                               "void d4_pow(d4_Type *a, int n, d4_Type *ret);\n"
                               "\n"
                               "bool d4_l(d4_Type *a, d4_Type *b) {\n"
                               "    return (a->x[0] < b->x[0] ||\n"
                               "            (a->x[0] == b->x[0] && (a->x[1] < b->x[1] ||\n"
                               "                                    (a->x[1] == b->x[1] && (a->x[2] < b->x[2] ||\n"
                               "                                                            (a->x[2] == b->x[2] && a->x[3] < b->x[3]))))));\n"
                               "}\n"
                               "\n"
                               "///implementation\n"
                               "void to_d4(stype x, d4_Type *ret) {\n"
                               "    ret->x[0] = x;\n"
                               "    ret->x[1] = 0.0;\n"
                               "    ret->x[2] = 0.0;\n"
                               "    ret->x[3] = 0.0;\n"
                               "}\n"
                               "\n"
                               "void d4_neg(d4_Type *x, d4_Type *ret) {\n"
                               "    ret->x[0] = -x->x[0];\n"
                               "    ret->x[1] = -x->x[1];\n"
                               "    ret->x[2] = -x->x[2];\n"
                               "    ret->x[3] = -x->x[3];\n"
                               "}\n"
                               "\n"
                               "void new_d4(stype d, stype d1, stype d2, stype d3, d4_Type *ret) {\n"
                               "    ret->x[0] = d;\n"
                               "    ret->x[1] = d1;\n"
                               "    ret->x[2] = d2;\n"
                               "    ret->x[3] = d3;\n"
                               "}\n"
                               "\n"
                               "void new_d4_(stype d, stype d1, stype d2, stype d3, __global d4_Type *ret) {\n"
                               "    ret->x[0] = d;\n"
                               "    ret->x[1] = d1;\n"
                               "    ret->x[2] = d2;\n"
                               "    ret->x[3] = d3;\n"
                               "}\n"
                               "\n"
                               "stype d4_quick_two_sum(stype a, stype b, stype *err) {\n"
                               "    stype s = a + b;\n"
                               "    (*err) = b - (s - a);\n"
                               "    return s;\n"
                               "}\n"
                               "\n"
                               "stype d4_two_sum(stype a, stype b, stype *err) {\n"
                               "    stype s = a + b;\n"
                               "    stype bb = s - a;\n"
                               "    (*err) = (a - (s - bb)) + (b - bb);\n"
                               "    return s;\n"
                               "}\n"
                               "\n"
                               "stype d4_quick_three_accum(stype *a, stype *b, stype c) {\n"
                               "    stype s;\n"
                               "    bool za, zb;\n"
                               "\n"
                               "    s = d4_two_sum((*b), c, b);\n"
                               "    s = d4_two_sum((*a), s, a);\n"
                               "\n"
                               "    za = ((*a) != 0.0);\n"
                               "    zb = ((*b) != 0.0);\n"
                               "\n"
                               "    if (za && zb)\n"
                               "        return s;\n"
                               "\n"
                               "    if (!zb) {\n"
                               "        (*b) = (*a);\n"
                               "        (*a) = s;\n"
                               "    } else {\n"
                               "        (*a) = s;\n"
                               "    }\n"
                               "\n"
                               "    return 0.0;\n"
                               "}\n"
                               "\n"
                               "void d4_renorm(stype *c0, stype *c1, stype *c2, stype *c3) {\n"
                               "    stype s0, s1, s2 = 0.0, s3 = 0.0;\n"
                               "\n"
                               "    if (isinf((*c0))) return;\n"
                               "\n"
                               "    s0 = d4_quick_two_sum((*c2), (*c3), c3);\n"
                               "    s0 = d4_quick_two_sum((*c1), s0, c2);\n"
                               "    (*c0) = d4_quick_two_sum((*c0), s0, c1);\n"
                               "\n"
                               "    s0 = (*c0);\n"
                               "    s1 = (*c1);\n"
                               "    if (s1 != 0.0) {\n"
                               "        s1 = d4_quick_two_sum(s1, (*c2), &s2);\n"
                               "        if (s2 != 0.0)\n"
                               "            s2 = d4_quick_two_sum(s2, (*c3), &s3);\n"
                               "        else\n"
                               "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                               "    } else {\n"
                               "        s0 = d4_quick_two_sum(s0, (*c2), &s1);\n"
                               "        if (s1 != 0.0)\n"
                               "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                               "        else\n"
                               "            s0 = d4_quick_two_sum(s0, (*c3), &s1);\n"
                               "    }\n"
                               "\n"
                               "    (*c0) = s0;\n"
                               "    (*c1) = s1;\n"
                               "    (*c2) = s2;\n"
                               "    (*c3) = s3;\n"
                               "}\n"
                               "\n"
                               "void d4_add(__global d4_Type *a, __global d4_Type *b, __global d4_Type *ret) {\n"
                               "    int i, j, k;\n"
                               "    stype s, t;\n"
                               "    stype u, v;\n"
                               "    d4_Type x;\n"
                               "    to_d4(0.0, &x);\n"
                               "\n"
                               "    i = j = k = 0;\n"
                               "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                               "        u = a->x[i++];\n"
                               "    else\n"
                               "        u = b->x[j++];\n"
                               "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                               "        v = a->x[i++];\n"
                               "    else\n"
                               "        v = b->x[j++];\n"
                               "\n"
                               "    u = d4_quick_two_sum(u, v, &v);\n"
                               "\n"
                               "    while (k < 4) {\n"
                               "        if (i >= 4 && j >= 4) {\n"
                               "            x.x[k] = u;\n"
                               "            if (k < 3)\n"
                               "                x.x[++k] = v;\n"
                               "            break;\n"
                               "        }\n"
                               "\n"
                               "        if (i >= 4)\n"
                               "            t = b->x[j++];\n"
                               "        else if (j >= 4)\n"
                               "            t = a->x[i++];\n"
                               "        else if (fabs(a->x[i]) > fabs(b->x[j])) {\n"
                               "            t = a->x[i++];\n"
                               "        } else\n"
                               "            t = b->x[j++];\n"
                               "\n"
                               "        s = d4_quick_three_accum(&u, &v, t);\n"
                               "\n"
                               "        if (s != 0.0) {\n"
                               "            x.x[k++] = s;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    for (k = i; k < 4; k++)\n"
                               "        x.x[3] += a->x[k];\n"
                               "    for (k = j; k < 4; k++)\n"
                               "        x.x[3] += b->x[k];\n"
                               "\n"
                               "    d4_renorm(&x.x[0], &x.x[1], &x.x[2], &x.x[3]);\n"
                               "    d4_assign_(ret, &x);\n"
                               "}\n"
                               "\n"
                               "void d4_add1(d4_Type *a, __global d4_Type *b, d4_Type *ret) {\n"
                               "    int i, j, k;\n"
                               "    stype s, t;\n"
                               "    stype u, v;\n"
                               "    d4_Type x;\n"
                               "    to_d4(0.0, &x);\n"
                               "\n"
                               "    i = j = k = 0;\n"
                               "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                               "        u = a->x[i++];\n"
                               "    else\n"
                               "        u = b->x[j++];\n"
                               "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                               "        v = a->x[i++];\n"
                               "    else\n"
                               "        v = b->x[j++];\n"
                               "\n"
                               "    u = d4_quick_two_sum(u, v, &v);\n"
                               "\n"
                               "    while (k < 4) {\n"
                               "        if (i >= 4 && j >= 4) {\n"
                               "            x.x[k] = u;\n"
                               "            if (k < 3)\n"
                               "                x.x[++k] = v;\n"
                               "            break;\n"
                               "        }\n"
                               "\n"
                               "        if (i >= 4)\n"
                               "            t = b->x[j++];\n"
                               "        else if (j >= 4)\n"
                               "            t = a->x[i++];\n"
                               "        else if (fabs(a->x[i]) > fabs(b->x[j])) {\n"
                               "            t = a->x[i++];\n"
                               "        } else\n"
                               "            t = b->x[j++];\n"
                               "\n"
                               "        s = d4_quick_three_accum(&u, &v, t);\n"
                               "\n"
                               "        if (s != 0.0) {\n"
                               "            x.x[k++] = s;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    for (k = i; k < 4; k++)\n"
                               "        x.x[3] += a->x[k];\n"
                               "    for (k = j; k < 4; k++)\n"
                               "        x.x[3] += b->x[k];\n"
                               "\n"
                               "    d4_renorm(&x.x[0], &x.x[1], &x.x[2], &x.x[3]);\n"
                               "    d4_assign(ret, &x);\n"
                               "}\n"
                               "\n"
                               "void d4_add2(__global d4_Type *a, d4_Type *b, __global d4_Type *ret) {\n"
                               "    int i, j, k;\n"
                               "    stype s, t;\n"
                               "    stype u, v;\n"
                               "    d4_Type x;\n"
                               "    to_d4(0.0, &x);\n"
                               "\n"
                               "    i = j = k = 0;\n"
                               "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                               "        u = a->x[i++];\n"
                               "    else\n"
                               "        u = b->x[j++];\n"
                               "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                               "        v = a->x[i++];\n"
                               "    else\n"
                               "        v = b->x[j++];\n"
                               "\n"
                               "    u = d4_quick_two_sum(u, v, &v);\n"
                               "\n"
                               "    while (k < 4) {\n"
                               "        if (i >= 4 && j >= 4) {\n"
                               "            x.x[k] = u;\n"
                               "            if (k < 3)\n"
                               "                x.x[++k] = v;\n"
                               "            break;\n"
                               "        }\n"
                               "\n"
                               "        if (i >= 4)\n"
                               "            t = b->x[j++];\n"
                               "        else if (j >= 4)\n"
                               "            t = a->x[i++];\n"
                               "        else if (fabs(a->x[i]) > fabs(b->x[j])) {\n"
                               "            t = a->x[i++];\n"
                               "        } else\n"
                               "            t = b->x[j++];\n"
                               "\n"
                               "        s = d4_quick_three_accum(&u, &v, t);\n"
                               "\n"
                               "        if (s != 0.0) {\n"
                               "            x.x[k++] = s;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    for (k = i; k < 4; k++)\n"
                               "        x.x[3] += a->x[k];\n"
                               "    for (k = j; k < 4; k++)\n"
                               "        x.x[3] += b->x[k];\n"
                               "\n"
                               "    d4_renorm(&x.x[0], &x.x[1], &x.x[2], &x.x[3]);\n"
                               "    d4_assign_(ret, &x);\n"
                               "}\n"
                               "\n"
                               "void d4_add_(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                               "    int i, j, k;\n"
                               "    stype s, t;\n"
                               "    stype u, v;\n"
                               "    d4_Type x;\n"
                               "    to_d4(0.0, &x);\n"
                               "\n"
                               "    i = j = k = 0;\n"
                               "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                               "        u = a->x[i++];\n"
                               "    else\n"
                               "        u = b->x[j++];\n"
                               "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                               "        v = a->x[i++];\n"
                               "    else\n"
                               "        v = b->x[j++];\n"
                               "\n"
                               "    u = d4_quick_two_sum(u, v, &v);\n"
                               "\n"
                               "    while (k < 4) {\n"
                               "        if (i >= 4 && j >= 4) {\n"
                               "            x.x[k] = u;\n"
                               "            if (k < 3)\n"
                               "                x.x[++k] = v;\n"
                               "            break;\n"
                               "        }\n"
                               "\n"
                               "        if (i >= 4)\n"
                               "            t = b->x[j++];\n"
                               "        else if (j >= 4)\n"
                               "            t = a->x[i++];\n"
                               "        else if (fabs(a->x[i]) > fabs(b->x[j])) {\n"
                               "            t = a->x[i++];\n"
                               "        } else\n"
                               "            t = b->x[j++];\n"
                               "\n"
                               "        s = d4_quick_three_accum(&u, &v, t);\n"
                               "\n"
                               "        if (s != 0.0) {\n"
                               "            x.x[k++] = s;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    for (k = i; k < 4; k++)\n"
                               "        x.x[3] += a->x[k];\n"
                               "    for (k = j; k < 4; k++)\n"
                               "        x.x[3] += b->x[k];\n"
                               "\n"
                               "    d4_renorm(&x.x[0], &x.x[1], &x.x[2], &x.x[3]);\n"
                               "    d4_assign(ret, &x);\n"
                               "}\n"
                               "\n"
                               "void d4_split(stype a, stype *hi, stype *lo) {\n"
                               "    stype temp;\n"
                               "    if (a > _QD_SPLIT_THRESH || a < -_QD_SPLIT_THRESH) {\n"
                               "        a *= 3.7252902984619140625e-09; // 2^-28\n"
                               "        temp = _QD_SPLITTER * a;\n"
                               "        (*hi) = temp - (temp - a);\n"
                               "        (*lo) = a - (*hi);\n"
                               "        (*hi) *= 268435456.0;\n"
                               "        (*lo) *= 268435456.0;\n"
                               "    } else {\n"
                               "        temp = _QD_SPLITTER * a;\n"
                               "        (*hi) = temp - (temp - a);\n"
                               "        (*lo) = a - (*hi);\n"
                               "    }\n"
                               "}\n"
                               "\n"
                               "stype d4_two_prod(stype a, stype b, stype *err) {\n"
                               "    stype a_hi, a_lo, b_hi, b_lo;\n"
                               "    stype p = a * b;\n"
                               "    d4_split(a, &a_hi, &a_lo);\n"
                               "    d4_split(b, &b_hi, &b_lo);\n"
                               "    (*err) = ((a_hi * b_hi - p) + a_hi * b_lo + a_lo * b_hi) + a_lo * b_lo;\n"
                               "    return p;\n"
                               "}\n"
                               "\n"
                               "void d4_three_sum(stype *a, stype *b, stype *c) {\n"
                               "    stype t1, t2, t3;\n"
                               "    t1 = d4_two_sum((*a), (*b), &t2);\n"
                               "    (*a) = d4_two_sum((*c), t1, &t3);\n"
                               "    (*b) = d4_two_sum(t2, t3, c);\n"
                               "}\n"
                               "\n"
                               "void d4_renorm_(stype *c0, stype *c1, stype *c2, stype *c3, stype *c4) {\n"
                               "    stype s0, s1, s2 = 0.0, s3 = 0.0;\n"
                               "\n"
                               "    if (isinf((*c0))) return;\n"
                               "\n"
                               "    s0 = d4_quick_two_sum((*c3), (*c4), c4);\n"
                               "    s0 = d4_quick_two_sum((*c2), s0, c3);\n"
                               "    s0 = d4_quick_two_sum((*c1), s0, c2);\n"
                               "    (*c0) = d4_quick_two_sum((*c0), s0, c1);\n"
                               "\n"
                               "    s0 = (*c0);\n"
                               "    s1 = (*c1);\n"
                               "\n"
                               "    s0 = d4_quick_two_sum((*c0), (*c1), &s1);\n"
                               "    if (s1 != 0.0) {\n"
                               "        s1 = d4_quick_two_sum(s1, (*c2), &s2);\n"
                               "        if (s2 != 0.0) {\n"
                               "            s2 = d4_quick_two_sum(s2, (*c3), &s3);\n"
                               "            if (s3 != 0.0)\n"
                               "                s3 += (*c4);\n"
                               "            else\n"
                               "                s2 += (*c4);\n"
                               "        } else {\n"
                               "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                               "            if (s2 != 0.0)\n"
                               "                s2 = d4_quick_two_sum(s2, (*c4), &s3);\n"
                               "            else\n"
                               "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                               "        }\n"
                               "    } else {\n"
                               "        s0 = d4_quick_two_sum(s0, (*c2), &s1);\n"
                               "        if (s1 != 0.0) {\n"
                               "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                               "            if (s2 != 0.0)\n"
                               "                s2 = d4_quick_two_sum(s2, (*c4), &s3);\n"
                               "            else\n"
                               "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                               "        } else {\n"
                               "            s0 = d4_quick_two_sum(s0, (*c3), &s1);\n"
                               "            if (s1 != 0.0)\n"
                               "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                               "            else\n"
                               "                s0 = d4_quick_two_sum(s0, (*c4), &s1);\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    (*c0) = s0;\n"
                               "    (*c1) = s1;\n"
                               "    (*c2) = s2;\n"
                               "    (*c3) = s3;\n"
                               "}\n"
                               "\n"
                               "void d4_mul_l(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                               "    stype p0, p1, p2, p3, p4, p5;\n"
                               "    stype q0, q1, q2, q3, q4, q5;\n"
                               "    stype p6, p7, p8, p9;\n"
                               "    stype q6, q7, q8, q9;\n"
                               "    stype r0, r1;\n"
                               "    stype t0, t1;\n"
                               "    stype s0, s1, s2;\n"
                               "\n"
                               "    p0 = d4_two_prod(a->x[0], b->x[0], &q0);\n"
                               "\n"
                               "    p1 = d4_two_prod(a->x[0], b->x[1], &q1);\n"
                               "    p2 = d4_two_prod(a->x[1], b->x[0], &q2);\n"
                               "\n"
                               "    p3 = d4_two_prod(a->x[0], b->x[2], &q3);\n"
                               "    p4 = d4_two_prod(a->x[1], b->x[1], &q4);\n"
                               "    p5 = d4_two_prod(a->x[2], b->x[0], &q5);\n"
                               "\n"
                               "    d4_three_sum(&p1, &p2, &q0);\n"
                               "\n"
                               "    d4_three_sum(&p2, &q1, &q2);\n"
                               "    d4_three_sum(&p3, &p4, &p5);\n"
                               "\n"
                               "    s0 = d4_two_sum(p2, p3, &t0);\n"
                               "    s1 = d4_two_sum(q1, p4, &t1);\n"
                               "    s2 = q2 + p5;\n"
                               "    s1 = d4_two_sum(s1, t0, &t0);\n"
                               "    s2 += (t0 + t1);\n"
                               "\n"
                               "    p6 = d4_two_prod(a->x[0], b->x[3], &q6);\n"
                               "    p7 = d4_two_prod(a->x[1], b->x[2], &q7);\n"
                               "    p8 = d4_two_prod(a->x[2], b->x[1], &q8);\n"
                               "    p9 = d4_two_prod(a->x[3], b->x[0], &q9);\n"
                               "\n"
                               "    q0 = d4_two_sum(q0, q3, &q3);\n"
                               "    q4 = d4_two_sum(q4, q5, &q5);\n"
                               "    p6 = d4_two_sum(p6, p7, &p7);\n"
                               "    p8 = d4_two_sum(p8, p9, &p9);\n"
                               "\n"
                               "    t0 = d4_two_sum(q0, q4, &t1);\n"
                               "    t1 += (q3 + q5);\n"
                               "\n"
                               "    r0 = d4_two_sum(p6, p8, &r1);\n"
                               "    r1 += (p7 + p9);\n"
                               "\n"
                               "    q3 = d4_two_sum(t0, r0, &q4);\n"
                               "    q4 += (t1 + r1);\n"
                               "\n"
                               "    t0 = d4_two_sum(q3, s1, &t1);\n"
                               "    t1 += q4;\n"
                               "\n"
                               "    t1 += a->x[1] * b->x[3] + a->x[2] * b->x[2] + a->x[3] * b->x[1] + q6 + q7 + q8 + q9 + s2;\n"
                               "\n"
                               "    d4_renorm_(&p0, &p1, &s0, &t0, &t1);\n"
                               "    ret->x[0] = p0;\n"
                               "    ret->x[1] = p1;\n"
                               "    ret->x[2] = s0;\n"
                               "    ret->x[3] = t0;\n"
                               "}\n"
                               "\n"
                               "void d4_mul(__global d4_Type *a, __global d4_Type *b, d4_Type *ret) {\n"
                               "    stype p0, p1, p2, p3, p4, p5;\n"
                               "    stype q0, q1, q2, q3, q4, q5;\n"
                               "    stype p6, p7, p8, p9;\n"
                               "    stype q6, q7, q8, q9;\n"
                               "    stype r0, r1;\n"
                               "    stype t0, t1;\n"
                               "    stype s0, s1, s2;\n"
                               "\n"
                               "    p0 = d4_two_prod(a->x[0], b->x[0], &q0);\n"
                               "\n"
                               "    p1 = d4_two_prod(a->x[0], b->x[1], &q1);\n"
                               "    p2 = d4_two_prod(a->x[1], b->x[0], &q2);\n"
                               "\n"
                               "    p3 = d4_two_prod(a->x[0], b->x[2], &q3);\n"
                               "    p4 = d4_two_prod(a->x[1], b->x[1], &q4);\n"
                               "    p5 = d4_two_prod(a->x[2], b->x[0], &q5);\n"
                               "\n"
                               "    d4_three_sum(&p1, &p2, &q0);\n"
                               "\n"
                               "    d4_three_sum(&p2, &q1, &q2);\n"
                               "    d4_three_sum(&p3, &p4, &p5);\n"
                               "\n"
                               "    s0 = d4_two_sum(p2, p3, &t0);\n"
                               "    s1 = d4_two_sum(q1, p4, &t1);\n"
                               "    s2 = q2 + p5;\n"
                               "    s1 = d4_two_sum(s1, t0, &t0);\n"
                               "    s2 += (t0 + t1);\n"
                               "\n"
                               "    p6 = d4_two_prod(a->x[0], b->x[3], &q6);\n"
                               "    p7 = d4_two_prod(a->x[1], b->x[2], &q7);\n"
                               "    p8 = d4_two_prod(a->x[2], b->x[1], &q8);\n"
                               "    p9 = d4_two_prod(a->x[3], b->x[0], &q9);\n"
                               "\n"
                               "    q0 = d4_two_sum(q0, q3, &q3);\n"
                               "    q4 = d4_two_sum(q4, q5, &q5);\n"
                               "    p6 = d4_two_sum(p6, p7, &p7);\n"
                               "    p8 = d4_two_sum(p8, p9, &p9);\n"
                               "\n"
                               "    t0 = d4_two_sum(q0, q4, &t1);\n"
                               "    t1 += (q3 + q5);\n"
                               "\n"
                               "    r0 = d4_two_sum(p6, p8, &r1);\n"
                               "    r1 += (p7 + p9);\n"
                               "\n"
                               "    q3 = d4_two_sum(t0, r0, &q4);\n"
                               "    q4 += (t1 + r1);\n"
                               "\n"
                               "    t0 = d4_two_sum(q3, s1, &t1);\n"
                               "    t1 += q4;\n"
                               "\n"
                               "    t1 += a->x[1] * b->x[3] + a->x[2] * b->x[2] + a->x[3] * b->x[1] + q6 + q7 + q8 + q9 + s2;\n"
                               "\n"
                               "    d4_renorm_(&p0, &p1, &s0, &t0, &t1);\n"
                               "    ret->x[0] = p0;\n"
                               "    ret->x[1] = p1;\n"
                               "    ret->x[2] = s0;\n"
                               "    ret->x[3] = t0;\n"
                               "}\n"
                               "\n"
                               "\n"
                               "void d4_minus(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                               "    d4_Type c;\n"
                               "    d4_neg(b, &c);\n"
                               "    d4_Type d;\n"
                               "    d4_add_(a, &c, &d);\n"
                               "    d4_assign(ret, &d);\n"
                               "}\n"
                               "\n"
                               "void d4_three_sum2(stype *a, stype *b, stype *c) {\n"
                               "    stype t1, t2, t3;\n"
                               "    t1 = d4_two_sum((*a), (*b), &t2);\n"
                               "    (*a) = d4_two_sum((*c), t1, &t3);\n"
                               "    (*b) = t2 + t3;\n"
                               "}\n"
                               "\n"
                               "void d4_mul_qd_d(d4_Type *a, stype b, d4_Type *ret) {\n"
                               "    stype p0, p1, p2, p3;\n"
                               "    stype q0, q1, q2;\n"
                               "    stype s0, s1, s2, s3, s4;\n"
                               "\n"
                               "    p0 = d4_two_prod(a->x[0], b, &q0);\n"
                               "    p1 = d4_two_prod(a->x[1], b, &q1);\n"
                               "    p2 = d4_two_prod(a->x[2], b, &q2);\n"
                               "    p3 = a->x[3] * b;\n"
                               "\n"
                               "    s0 = p0;\n"
                               "\n"
                               "    s1 = d4_two_sum(q0, p1, &s2);\n"
                               "\n"
                               "    d4_three_sum(&s2, &q1, &p2);\n"
                               "\n"
                               "    d4_three_sum2(&q1, &q2, &p3);\n"
                               "    s3 = q1;\n"
                               "\n"
                               "    s4 = q2 + p2;\n"
                               "\n"
                               "    d4_renorm_(&s0, &s1, &s2, &s3, &s4);\n"
                               "    new_d4(s0, s1, s2, s3, ret);\n"
                               "}\n"
                               "\n"
                               "void d4_div(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                               "    stype q0, q1, q2, q3;\n"
                               "\n"
                               "    d4_Type r, tmp;\n"
                               "\n"
                               "    q0 = a->x[0] / b->x[0];\n"
                               "    d4_mul_qd_d(b, q0, &tmp);\n"
                               "    d4_minus(a, &tmp, &r);\n"
                               "\n"
                               "    q1 = r.x[0] / b->x[0];\n"
                               "    d4_mul_qd_d(b, q1, &tmp);\n"
                               "    d4_minus(&r, &tmp, &r);\n"
                               "\n"
                               "    q2 = r.x[0] / b->x[0];\n"
                               "    d4_mul_qd_d(b, q2, &tmp);\n"
                               "    d4_minus(&r, &tmp, &r);\n"
                               "\n"
                               "    q3 = r.x[0] / b->x[0];\n"
                               "    d4_mul_qd_d(b, q3, &tmp);\n"
                               "    d4_minus(&r, &tmp, &r);\n"
                               "\n"
                               "    stype q4 = r.x[0] / b->x[0];\n"
                               "\n"
                               "    d4_renorm_(&q0, &q1, &q2, &q3, &q4);\n"
                               "\n"
                               "    new_d4(q0, q1, q2, q3, ret);\n"
                               "}\n"
                               "\n"
                               "void d4_assign(d4_Type *a, d4_Type *b) {\n"
                               "    a->x[0] = b->x[0];\n"
                               "    a->x[1] = b->x[1];\n"
                               "    a->x[2] = b->x[2];\n"
                               "    a->x[3] = b->x[3];\n"
                               "}\n"
                               "\n"
                               "void d4_assign_(__global d4_Type *a, d4_Type *b) {\n"
                               "    a->x[0] = b->x[0];\n"
                               "    a->x[1] = b->x[1];\n"
                               "    a->x[2] = b->x[2];\n"
                               "    a->x[3] = b->x[3];\n"
                               "}\n"
                               "\n"
                               "\n"
                               "void d4_mul_w(d4_Type *a, __global d4_Type *b, d4_Type *ret) {\n"
                               "    stype p0, p1, p2, p3, p4, p5;\n"
                               "    stype q0, q1, q2, q3, q4, q5;\n"
                               "    stype p6, p7, p8, p9;\n"
                               "    stype q6, q7, q8, q9;\n"
                               "    stype r0, r1;\n"
                               "    stype t0, t1;\n"
                               "    stype s0, s1, s2;\n"
                               "\n"
                               "    p0 = d4_two_prod(a->x[0], b->x[0], &q0);\n"
                               "\n"
                               "    p1 = d4_two_prod(a->x[0], b->x[1], &q1);\n"
                               "    p2 = d4_two_prod(a->x[1], b->x[0], &q2);\n"
                               "\n"
                               "    p3 = d4_two_prod(a->x[0], b->x[2], &q3);\n"
                               "    p4 = d4_two_prod(a->x[1], b->x[1], &q4);\n"
                               "    p5 = d4_two_prod(a->x[2], b->x[0], &q5);\n"
                               "\n"
                               "    d4_three_sum(&p1, &p2, &q0);\n"
                               "\n"
                               "    d4_three_sum(&p2, &q1, &q2);\n"
                               "    d4_three_sum(&p3, &p4, &p5);\n"
                               "\n"
                               "    s0 = d4_two_sum(p2, p3, &t0);\n"
                               "    s1 = d4_two_sum(q1, p4, &t1);\n"
                               "    s2 = q2 + p5;\n"
                               "    s1 = d4_two_sum(s1, t0, &t0);\n"
                               "    s2 += (t0 + t1);\n"
                               "\n"
                               "    p6 = d4_two_prod(a->x[0], b->x[3], &q6);\n"
                               "    p7 = d4_two_prod(a->x[1], b->x[2], &q7);\n"
                               "    p8 = d4_two_prod(a->x[2], b->x[1], &q8);\n"
                               "    p9 = d4_two_prod(a->x[3], b->x[0], &q9);\n"
                               "\n"
                               "    q0 = d4_two_sum(q0, q3, &q3);\n"
                               "    q4 = d4_two_sum(q4, q5, &q5);\n"
                               "    p6 = d4_two_sum(p6, p7, &p7);\n"
                               "    p8 = d4_two_sum(p8, p9, &p9);\n"
                               "\n"
                               "    t0 = d4_two_sum(q0, q4, &t1);\n"
                               "    t1 += (q3 + q5);\n"
                               "\n"
                               "    r0 = d4_two_sum(p6, p8, &r1);\n"
                               "    r1 += (p7 + p9);\n"
                               "\n"
                               "    q3 = d4_two_sum(t0, r0, &q4);\n"
                               "    q4 += (t1 + r1);\n"
                               "\n"
                               "    t0 = d4_two_sum(q3, s1, &t1);\n"
                               "    t1 += q4;\n"
                               "\n"
                               "    t1 += a->x[1] * b->x[3] + a->x[2] * b->x[2] + a->x[3] * b->x[1] + q6 + q7 + q8 + q9 + s2;\n"
                               "\n"
                               "    d4_renorm_(&p0, &p1, &s0, &t0, &t1);\n"
                               "    ret->x[0] = p0;\n"
                               "    ret->x[1] = p1;\n"
                               "    ret->x[2] = s0;\n"
                               "    ret->x[3] = t0;\n"
                               "}");
std::string prim_kernel("#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
                                "#define stype double\n"
                                "//#define __global\n"
                                "//#define __kernel\n"
                                "\n"
                                "typedef struct {\n"
                                "    stype x[4];\n"
                                "} d4_Type;\n"
                                "\n"
                                "void d4_assign_(__global d4_Type *a, d4_Type *b);\n"
                                "\n"
                                "void d4_mul(d4_Type *a, __global d4_Type *b, __global d4_Type *ret);\n"
                                "\n"
                                "void d4_mul_w(d4_Type *a, __global d4_Type *b, d4_Type *ret);\n"
                                "\n"
                                "void d4_mul_w_(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                                "\n"
                                "void d4_add(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                                "\n"
                                "void d4_add_g(d4_Type *a, __global d4_Type *b, __global d4_Type *ret);\n"
                                "\n"
                                "void d4_div(__global d4_Type *a, d4_Type *b, __global d4_Type *ret);\n"
                                "\n"
                                "void d4_assign(d4_Type *a, d4_Type *b);\n"
                                "\n"
                                "void new_d4(stype d, stype d1, stype d2, stype d3, d4_Type *ret);\n"
                                "\n"
                                "void new_d4_(stype d, stype d1, stype d2, stype d3, __global d4_Type *ret);\n"
                                "\n"
                                "void to_d4(stype x, d4_Type *ret);\n"
                                "\n"
                                "/**\n"
                                " * Operation to solve a Introduce node in the decomposition.\n"
                                " *\n"
                                " * @param clauses\n"
                                " *      array containing the clauses in the sat formula\n"
                                " * @param numVarsC\n"
                                " *      array containing the number of variables for each clause\n"
                                " * @param numclauses\n"
                                " *      the number of clauses\n"
                                " * @param solutions\n"
                                " *      array for saving the number of models for each assignment\n"
                                " * @param numV\n"
                                " *      the number of variables in the current bag\n"
                                " * @param edge\n"
                                " *      the number of models for each assignment of the next bag\n"
                                " * @param numVE\n"
                                " *      the number of variables in the next bag\n"
                                " * @param variables\n"
                                " *      the ids of the variables in the current bag\n"
                                " * @param edgeVariables\n"
                                " *      the ids of the variables in the next bag\n"
                                " */\n"
                                "d4_Type solveIntroduce_(long numV, __global d4_Type *edge, long numVE, __global long *variables, __global long *edgeVariables, long minId, long maxId,\n"
                                "                        long startIDEdge, __global d4_Type *weights, long id) {\n"
                                "    long otherId = 0;\n"
                                "    long a = 0, b = 0;\n"
                                "    d4_Type weight;\n"
                                "    new_d4(1.0, 0.0, 0.0, 0.0, &weight);\n"
                                "    for (b = 0; b < numVE && a < numV; b++) {\n"
                                "        while ((variables[a] != edgeVariables[b])) {\n"
                                "            a++;\n"
                                "        }\n"
                                "        otherId = otherId | (((id >> a) & 1) << b);\n"
                                "        a++;\n"
                                "    };\n"
                                "\n"
                                "    //weighted model count\n"
                                "    if (weights != 0) {\n"
                                "        for (b = 0, a = 0; a < numV; a++) {\n"
                                "            if (edgeVariables == 0 || (variables[a] != edgeVariables[b])) {\n"
                                "                d4_mul_w(&weight, &weights[((id >> a) & 1) > 0 ? variables[a] * 2 : variables[a] * 2 + 1], &weight);\n"
                                "            }\n"
                                "            if (edgeVariables != 0 && (variables[a] == edgeVariables[b]) && (b < (numVE - 1))) {\n"
                                "                b++;\n"
                                "            }\n"
                                "        }\n"
                                "    }\n"
                                "\n"
                                "    if (edge != 0 && otherId >= (minId) && otherId < (maxId)) {\n"
                                "        d4_mul_w(&weight, &edge[otherId - (startIDEdge)], &weight);\n"
                                "        return weight;\n"
                                "    } else if (edge == 0 && otherId >= (minId) && otherId < (maxId)) {\n"
                                "        d4_Type ret;\n"
                                "        new_d4(0.0, 0.0, 0.0, 0.0, &ret);\n"
                                "        return ret;\n"
                                "    } else {\n"
                                "        d4_Type ret;\n"
                                "        new_d4(-1.0, 0.0, 0.0, 0.0, &ret);\n"
                                "        return ret;\n"
                                "    }\n"
                                "}\n"
                                "\n"
                                "/**\n"
                                " * Operation to check if an assignment satisfies the clauses of a SAT formula.\n"
                                " *\n"
                                " * @param clauses\n"
                                " *      the clauses in the SAT formula\n"
                                " * @param numVarsC\n"
                                " *      array containing the number of Variables in each clause\n"
                                " * @param numclauses\n"
                                " *      the number of clauses in the sat formula\n"
                                " * @param id\n"
                                " *      the id of the thread - used to get the variable assignment\n"
                                " * @param numV\n"
                                " *      the number of variables\n"
                                " * @param variables\n"
                                " *      a vector containing the ids of the variables\n"
                                " * @return\n"
                                " *      1 - if the assignment satisfies the formula\n"
                                " *      0 - if the assignment doesn't satisfy the formula\n"
                                " */\n"
                                "int checkBag(__global long *clauses, __global long *numVarsC, long numclauses, long id, long numV, __global long *variables) {\n"
                                "    long i, varNum = 0;\n"
                                "    long satC = 0, a, b;\n"
                                "    // iterate through all clauses\n"
                                "    for (i = 0; i < numclauses; i++) {\n"
                                "        satC = 0;\n"
                                "        // iterate through clause variables\n"
                                "        for (a = 0; a < numVarsC[i] && !satC; a++) {\n"
                                "            satC = 1;\n"
                                "            //check current variables\n"
                                "            for (b = 0; b < numV; b++) {\n"
                                "                // check if clause is satisfied\n"
                                "                if ((clauses[varNum + a] == variables[b]) ||\n"
                                "                    (clauses[varNum + a] == -variables[b])) {\n"
                                "                    satC = 0;\n"
                                "                    if (clauses[varNum + a] < 0) {\n"
                                "                        //clause contains negative var and var is assigned negative\n"
                                "                        if ((id & (1 << (b))) == 0) {\n"
                                "                            satC = 1;\n"
                                "                            break;\n"
                                "                        }\n"
                                "                    } else {\n"
                                "                        //clause contains positive var and var is assigned positive\n"
                                "                        if ((id & (1 << (b))) > 0) {\n"
                                "                            satC = 1;\n"
                                "                            break;\n"
                                "                        }\n"
                                "                    }\n"
                                "                }\n"
                                "            }\n"
                                "        }\n"
                                "        varNum += numVarsC[i];\n"
                                "        // we have an unsattisifed clause\n"
                                "        if (!satC) {\n"
                                "            return 0;\n"
                                "        }\n"
                                "    }\n"
                                "    return 1;\n"
                                "}\n"
                                "\n"
                                "/**\n"
                                " * Operation to solve a Join node in the decomposition.\n"
                                " *\n"
                                " * @param solutions\n"
                                " *      array to save the number of solutions of the join\n"
                                " * @param edge1\n"
                                " *      array containing the number of solutions in the first edge\n"
                                " * @param edge2\n"
                                " *      array containing the number of solutions in the second edge\n"
                                " * @param variables\n"
                                " *      the variables in the join bag\n"
                                " * @param edgeVariables1\n"
                                " *      the variables in the bag of the first edge\n"
                                " * @param edgeVariables2\n"
                                " *      the variables in the bag of the second edge\n"
                                " * @param numV\n"
                                " *      the number of variables in the join bag\n"
                                " * @param numVE1\n"
                                " *      the number of variables in the first edge\n"
                                " * @param numVE2\n"
                                " *      the number of variables in the second edge\n"
                                " */\n"
                                "__kernel void solveJoin(__global d4_Type *solutions, __global d4_Type *edge1, __global d4_Type *edge2, __global long *variables, __global long *edgeVariables1,\n"
                                "                        __global long *edgeVariables2, long numV, long numVE1, long numVE2, long minId1, long maxId1, long minId2,\n"
                                "                        long maxId2, long startIDNode, long startIDEdge1, long startIDEdge2, __global d4_Type *weights, __global int *sols) {\n"
                                "    long id = get_global_id(0);\n"
                                "    d4_Type tmp, tmp_;\n"
                                "    d4_Type weight;\n"
                                "    new_d4(1.0, 0.0, 0.0, 0.0, &weight);\n"
                                "    new_d4(-1.0, 0.0, 0.0, 0.0, &tmp);\n"
                                "    new_d4(-1.0, 0.0, 0.0, 0.0, &tmp_);\n"
                                "// get solution count from first edge\n"
                                "    tmp = solveIntroduce_(numV, edge1, numVE1, variables, edgeVariables1, minId1, maxId1, startIDEdge1, weights, id);\n"
                                "// get solution count from second edge\n"
                                "    tmp_ = solveIntroduce_(numV, edge2, numVE2, variables, edgeVariables2, minId2, maxId2, startIDEdge2, weights, id);\n"
                                "// weighted model count\n"
                                "    if (weights != 0) {\n"
                                "        for (int a = 0; a < numV; a++) {\n"
                                "            d4_mul_w(&weight, &weights[((id >> a) & 1) > 0 ? variables[a] * 2 : variables[a] * 2 + 1], &weight);\n"
                                "        }\n"
                                "    }\n"
                                "\n"
                                "// we have some solutions in edge1\n"
                                "    if (tmp.x[0] >= 0.0) {\n"
                                "        d4_mul(&tmp, &solutions[id - (startIDNode)], &solutions[id - (startIDNode)]);\n"
                                "        d4_div( &solutions[id - (startIDNode)],&weight, &solutions[id - (startIDNode)]);\n"
                                "    }\n"
                                "\n"
                                "// we have some solutions in edge2\n"
                                "    if (tmp_.x[0] >= 0.0) {\n"
                                "        d4_mul(&tmp_, &solutions[id - (startIDNode)], &solutions[id - (startIDNode)]);\n"
                                "    }\n"
                                "\n"
                                "    if (solutions[id - (startIDNode)].x[0] > 0) {\n"
                                "        *sols = 1;\n"
                                "    }\n"
                                "}\n"
                                "\n"
                                "/**\n"
                                " * Operation to solve a Introduce node in the decomposition.\n"
                                " *\n"
                                " * @param clauses\n"
                                " *      array containing the clauses in the sat formula\n"
                                " * @param numVarsC\n"
                                " *      array containing the number of variables for each clause\n"
                                " * @param numclauses\n"
                                " *      the number of clauses\n"
                                " * @param solutions\n"
                                " *      array for saving the number of models for each assignment\n"
                                " * @param numV\n"
                                " *      the number of variables in the current bag\n"
                                " * @param edge\n"
                                " *      the number of models for each assignment of the next bag\n"
                                " * @param numVE\n"
                                " *      the number of variables in the next bag\n"
                                " * @param variables\n"
                                " *      the ids of the variables in the current bag\n"
                                " * @param edgeVariables\n"
                                " *      the ids of the variables in the next bag\n"
                                " */\n"
                                "d4_Type solveIntroduceF(__global long *clauses, __global long *numVarsC, long numclauses, long numV, __global d4_Type *edge, long numVE,\n"
                                "                        __global long *variables, __global long *edgeVariables, long minId, long maxId,\n"
                                "                        long startIDEdge, __global d4_Type *weights, long id) {\n"
                                "    d4_Type tmp;\n"
                                "    if (edge != 0) {\n"
                                "// get solutions count edge\n"
                                "        tmp = solveIntroduce_(numV, edge, numVE, variables, edgeVariables, minId, maxId, startIDEdge, weights, id);\n"
                                "    } else {\n"
                                "// no edge - solve leaf\n"
                                "        new_d4(1.0, 0.0, 0.0, 0.0, &tmp);\n"
                                "\n"
                                "//weighted model count\n"
                                "        if (weights != 0) {\n"
                                "            for (int i = 0; i < numV; i++) {\n"
                                "                d4_mul_w(&tmp, &weights[((id >> i) & 1) > 0 ? variables[i] * 2 : variables[i] * 2 + 1], &tmp);\n"
                                "            }\n"
                                "        }\n"
                                "    }\n"
                                "    if (tmp.x[0] > 0.0) {\n"
                                "// check if assignment satisfies the given clauses\n"
                                "        int sat = checkBag(clauses, numVarsC, numclauses, id, numV, variables);\n"
                                "        if (sat != 1) {\n"
                                "            d4_Type ret;\n"
                                "            new_d4(0.0,0.0,0.0,0.0,&ret);\n"
                                "            return ret;\n"
                                "        } else {\n"
                                "            return tmp;\n"
                                "        }\n"
                                "    } else {\n"
                                "        d4_Type ret;\n"
                                "        new_d4(0.0,0.0,0.0,0.0,&ret);\n"
                                "        return ret;\n"
                                "    }\n"
                                "}\n"
                                "\n"
                                "\n"
                                "/**\n"
                                " * Operation to solve a Forget node in the decomposition.\n"
                                " *\n"
                                " * @param solutions\n"
                                " *      array for saving the number of models for each assignment\n"
                                " * @param variablesCurrent\n"
                                " *      array containing the ids of the variables in the current bag\n"
                                " * @param edge\n"
                                " *      array containing the solutions in the last node\n"
                                " * @param numVarsEdge\n"
                                " *      number of variables in the edge bag\n"
                                " * @param variablesEdge\n"
                                " *      array containing the ids of the variables in the next bag\n"
                                " * @param combinations\n"
                                " *      the number of solutions that relate to this bag from the next bag\n"
                                " * @param numVarsCurrent\n"
                                " *      number of variables in the current bag\n"
                                " * @param clauses\n"
                                " *      array containing the clauses in the sat formula\n"
                                " * @param numVarsC\n"
                                " *      array containing the number of variables for each clause\n"
                                " * @param numclauses\n"
                                " *      the number of clauses\n"
                                " * @param solutions\n"
                                " *      array for saving the number of models for each assignment\n"
                                " * @param numV\n"
                                " *      the number of variables in the current bag\n"
                                " * @param edge\n"
                                " *      the number of models for each assignment of the next bag\n"
                                " * @param numVE\n"
                                " *      the number of variables in the next bag\n"
                                " * @param variables\n"
                                " *      the ids of the variables in the current bag\n"
                                " * @param edgeVariables\n"
                                " *      the ids of the variables in the next bag\n"
                                " */\n"
                                "__kernel void solveIntroduceForget(__global d4_Type *solsF, __global long *varsF, __global d4_Type *solsE,\n"
                                "                                   long numVE, __global long *varsE, long combinations, long numVF,\n"
                                "                                   long minIdE, long maxIdE, long startIDF,\n"
                                "                                   long startIDE, __global int *sols,\n"
                                "                                   long numVI, __global long *varsI,\n"
                                "                                   __global long *clauses, __global long *numVarsC, long numclauses, __global d4_Type *weights) {\n"
                                "    long id = get_global_id(0);\n"
                                "    if (numVI != numVF) {\n"
                                "        long templateId = 0;\n"
                                "// generate templateId\n"
                                "        for (int i = 0, a = 0; i < numVI && a < numVF; i++) {\n"
                                "            if (varsI[i] == varsF[a]) {\n"
                                "                templateId = templateId | (((id >> a) & 1) << i);\n"
                                "                a++;\n"
                                "            }\n"
                                "        }\n"
                                "\n"
                                "// iterate through all corresponding edge solutions\n"
                                "        for (int i = 0; i < combinations; i++) {\n"
                                "            long b = 0, otherId = templateId;\n"
                                "            for (int a = 0; a < numVI; a++) {\n"
                                "                if (b >= numVF || varsI[a] != varsF[b]) {\n"
                                "                    otherId = otherId | (((i >> (a - b)) & 1) << a);\n"
                                "                } else {\n"
                                "                    b++;\n"
                                "                }\n"
                                "            }\n"
                                "// get solution count of the corresponding assignment in the edge\n"
                                "            d4_Type tmp = solveIntroduceF(clauses, numVarsC, numclauses, numVI, solsE, numVE, varsI, varsE, minIdE, maxIdE, startIDE, weights, otherId);\n"
                                "            d4_add_g(&tmp, &solsF[id - (startIDF)], &solsF[id - (startIDF)]);\n"
                                "        }\n"
                                "    } else {\n"
                                "// no forget variables, only introduce\n"
                                "        d4_Type tmp = solveIntroduceF(clauses, numVarsC, numclauses, numVI, solsE, numVE, varsI, varsE, minIdE, maxIdE, startIDE, weights, id);\n"
                                "        d4_add_g(&tmp, &solsF[id - (startIDF)], &solsF[id - (startIDF)]);\n"
                                "    }\n"
                                "    if (solsF[id - (startIDF)].x[0] > 0) {\n"
                                "        *sols = 1;\n"
                                "    }\n"
                                "}\n"
                                "\n"
                                "/**\n"
                                " * adaptation of https://github.com/scibuilder/QD for opencl\n"
                                " */\n"
                                "\n"
                                "///headers\n"
                                "#define _QD_SPLITTER 134217729.0 // = 2^27 + 1\n"
                                "#define _QD_SPLIT_THRESH 6.69692879491417e+299 // = 2^996\n"
                                "\n"
                                "void d4_neg(d4_Type *x, d4_Type *ret);\n"
                                "\n"
                                "void d4_minus(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                                "\n"
                                "void d4_log(d4_Type *a, d4_Type *ret);\n"
                                "\n"
                                "stype d4_quick_two_sum(stype a, stype b, stype *err);\n"
                                "\n"
                                "stype d4_two_sum(stype a, stype b, stype *err);\n"
                                "\n"
                                "stype d4_quick_three_accum(stype *a, stype *b, stype c);\n"
                                "\n"
                                "void d4_renorm(stype *c0, stype *c1, stype *c2, stype *c3);\n"
                                "\n"
                                "void d4_split(stype a, stype *hi, stype *lo);\n"
                                "\n"
                                "stype d4_two_prod(stype a, stype b, stype *err);\n"
                                "\n"
                                "void d4_three_sum(stype *a, stype *b, stype *c);\n"
                                "\n"
                                "void d4_renorm_(stype *c0, stype *c1, stype *c2, stype *c3, stype *c4);\n"
                                "\n"
                                "void d4_three_sum2(stype *a, stype *b, stype *c);;\n"
                                "\n"
                                "void d4_mul_qd_d(d4_Type *a, stype b, d4_Type *ret);\n"
                                "\n"
                                "void d4_ldexp(d4_Type *a, int n, d4_Type *ret);\n"
                                "\n"
                                "bool d4_is_zero(d4_Type *x);\n"
                                "\n"
                                "bool d4_is_one(d4_Type *x);\n"
                                "\n"
                                "void d4_mul_pwr2(d4_Type *a, stype b, d4_Type *ret);\n"
                                "\n"
                                "void d4_sqr(d4_Type *a, d4_Type *ret);\n"
                                "\n"
                                "void d4_pow(d4_Type *a, int n, d4_Type *ret);\n"
                                "\n"
                                "bool d4_l(d4_Type *a, d4_Type *b) {\n"
                                "    return (a->x[0] < b->x[0] ||\n"
                                "            (a->x[0] == b->x[0] && (a->x[1] < b->x[1] ||\n"
                                "                                    (a->x[1] == b->x[1] && (a->x[2] < b->x[2] ||\n"
                                "                                                            (a->x[2] == b->x[2] && a->x[3] < b->x[3]))))));\n"
                                "}\n"
                                "\n"
                                "///implementation\n"
                                "void to_d4(stype x, d4_Type *ret) {\n"
                                "    ret->x[0] = x;\n"
                                "    ret->x[1] = 0.0;\n"
                                "    ret->x[2] = 0.0;\n"
                                "    ret->x[3] = 0.0;\n"
                                "}\n"
                                "\n"
                                "void d4_neg(d4_Type *x, d4_Type *ret) {\n"
                                "    ret->x[0] = -x->x[0];\n"
                                "    ret->x[1] = -x->x[1];\n"
                                "    ret->x[2] = -x->x[2];\n"
                                "    ret->x[3] = -x->x[3];\n"
                                "}\n"
                                "\n"
                                "void new_d4(stype d, stype d1, stype d2, stype d3, d4_Type *ret) {\n"
                                "    ret->x[0] = d;\n"
                                "    ret->x[1] = d1;\n"
                                "    ret->x[2] = d2;\n"
                                "    ret->x[3] = d3;\n"
                                "}\n"
                                "\n"
                                "void new_d4_(stype d, stype d1, stype d2, stype d3, __global d4_Type *ret) {\n"
                                "    ret->x[0] = d;\n"
                                "    ret->x[1] = d1;\n"
                                "    ret->x[2] = d2;\n"
                                "    ret->x[3] = d3;\n"
                                "}\n"
                                "\n"
                                "stype d4_quick_two_sum(stype a, stype b, stype *err) {\n"
                                "    stype s = a + b;\n"
                                "    (*err) = b - (s - a);\n"
                                "    return s;\n"
                                "}\n"
                                "\n"
                                "stype d4_two_sum(stype a, stype b, stype *err) {\n"
                                "    stype s = a + b;\n"
                                "    stype bb = s - a;\n"
                                "    (*err) = (a - (s - bb)) + (b - bb);\n"
                                "    return s;\n"
                                "}\n"
                                "\n"
                                "stype d4_quick_three_accum(stype *a, stype *b, stype c) {\n"
                                "    stype s;\n"
                                "    bool za, zb;\n"
                                "\n"
                                "    s = d4_two_sum((*b), c, b);\n"
                                "    s = d4_two_sum((*a), s, a);\n"
                                "\n"
                                "    za = ((*a) != 0.0);\n"
                                "    zb = ((*b) != 0.0);\n"
                                "\n"
                                "    if (za && zb)\n"
                                "        return s;\n"
                                "\n"
                                "    if (!zb) {\n"
                                "        (*b) = (*a);\n"
                                "        (*a) = s;\n"
                                "    } else {\n"
                                "        (*a) = s;\n"
                                "    }\n"
                                "\n"
                                "    return 0.0;\n"
                                "}\n"
                                "\n"
                                "void d4_renorm(stype *c0, stype *c1, stype *c2, stype *c3) {\n"
                                "    stype s0, s1, s2 = 0.0, s3 = 0.0;\n"
                                "\n"
                                "    if (isinf((*c0))) return;\n"
                                "\n"
                                "    s0 = d4_quick_two_sum((*c2), (*c3), c3);\n"
                                "    s0 = d4_quick_two_sum((*c1), s0, c2);\n"
                                "    (*c0) = d4_quick_two_sum((*c0), s0, c1);\n"
                                "\n"
                                "    s0 = (*c0);\n"
                                "    s1 = (*c1);\n"
                                "    if (s1 != 0.0) {\n"
                                "        s1 = d4_quick_two_sum(s1, (*c2), &s2);\n"
                                "        if (s2 != 0.0)\n"
                                "            s2 = d4_quick_two_sum(s2, (*c3), &s3);\n"
                                "        else\n"
                                "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                                "    } else {\n"
                                "        s0 = d4_quick_two_sum(s0, (*c2), &s1);\n"
                                "        if (s1 != 0.0)\n"
                                "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                                "        else\n"
                                "            s0 = d4_quick_two_sum(s0, (*c3), &s1);\n"
                                "    }\n"
                                "\n"
                                "    (*c0) = s0;\n"
                                "    (*c1) = s1;\n"
                                "    (*c2) = s2;\n"
                                "    (*c3) = s3;\n"
                                "}\n"
                                "\n"
                                "void d4_add_g(d4_Type *a, __global d4_Type *b, __global d4_Type *ret) {\n"
                                "    int i, j, k;\n"
                                "    stype s, t;\n"
                                "    stype u, v;\n"
                                "    d4_Type x;\n"
                                "    to_d4(0.0, &x);\n"
                                "\n"
                                "    i = j = k = 0;\n"
                                "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                                "        u = a->x[i++];\n"
                                "    else\n"
                                "        u = b->x[j++];\n"
                                "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                                "        v = a->x[i++];\n"
                                "    else\n"
                                "        v = b->x[j++];\n"
                                "\n"
                                "    u = d4_quick_two_sum(u, v, &v);\n"
                                "\n"
                                "    while (k < 4) {\n"
                                "        if (i >= 4 && j >= 4) {\n"
                                "            x.x[k] = u;\n"
                                "            if (k < 3)\n"
                                "                x.x[++k] = v;\n"
                                "            break;\n"
                                "        }\n"
                                "\n"
                                "        if (i >= 4)\n"
                                "            t = b->x[j++];\n"
                                "        else if (j >= 4)\n"
                                "            t = a->x[i++];\n"
                                "        else if (fabs(a->x[i]) > fabs(b->x[j])) {\n"
                                "            t = a->x[i++];\n"
                                "        } else\n"
                                "            t = b->x[j++];\n"
                                "\n"
                                "        s = d4_quick_three_accum(&u, &v, t);\n"
                                "\n"
                                "        if (s != 0.0) {\n"
                                "            x.x[k++] = s;\n"
                                "        }\n"
                                "    }\n"
                                "\n"
                                "    for (k = i; k < 4; k++)\n"
                                "        x.x[3] += a->x[k];\n"
                                "    for (k = j; k < 4; k++)\n"
                                "        x.x[3] += b->x[k];\n"
                                "\n"
                                "    d4_renorm(&x.x[0], &x.x[1], &x.x[2], &x.x[3]);\n"
                                "    d4_assign_(ret, &x);\n"
                                "}\n"
                                "\n"
                                "void d4_add(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                                "    int i, j, k;\n"
                                "    stype s, t;\n"
                                "    stype u, v;\n"
                                "    d4_Type x;\n"
                                "    to_d4(0.0, &x);\n"
                                "\n"
                                "    i = j = k = 0;\n"
                                "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                                "        u = a->x[i++];\n"
                                "    else\n"
                                "        u = b->x[j++];\n"
                                "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                                "        v = a->x[i++];\n"
                                "    else\n"
                                "        v = b->x[j++];\n"
                                "\n"
                                "    u = d4_quick_two_sum(u, v, &v);\n"
                                "\n"
                                "    while (k < 4) {\n"
                                "        if (i >= 4 && j >= 4) {\n"
                                "            x.x[k] = u;\n"
                                "            if (k < 3)\n"
                                "                x.x[++k] = v;\n"
                                "            break;\n"
                                "        }\n"
                                "\n"
                                "        if (i >= 4)\n"
                                "            t = b->x[j++];\n"
                                "        else if (j >= 4)\n"
                                "            t = a->x[i++];\n"
                                "        else if (fabs(a->x[i]) > fabs(b->x[j])) {\n"
                                "            t = a->x[i++];\n"
                                "        } else\n"
                                "            t = b->x[j++];\n"
                                "\n"
                                "        s = d4_quick_three_accum(&u, &v, t);\n"
                                "\n"
                                "        if (s != 0.0) {\n"
                                "            x.x[k++] = s;\n"
                                "        }\n"
                                "    }\n"
                                "\n"
                                "    for (k = i; k < 4; k++)\n"
                                "        x.x[3] += a->x[k];\n"
                                "    for (k = j; k < 4; k++)\n"
                                "        x.x[3] += b->x[k];\n"
                                "\n"
                                "    d4_renorm(&x.x[0], &x.x[1], &x.x[2], &x.x[3]);\n"
                                "    d4_assign(ret, &x);\n"
                                "}\n"
                                "\n"
                                "void d4_split(stype a, stype *hi, stype *lo) {\n"
                                "    stype temp;\n"
                                "    if (a > _QD_SPLIT_THRESH || a < -_QD_SPLIT_THRESH) {\n"
                                "        a *= 3.7252902984619140625e-09; // 2^-28\n"
                                "        temp = _QD_SPLITTER * a;\n"
                                "        (*hi) = temp - (temp - a);\n"
                                "        (*lo) = a - (*hi);\n"
                                "        (*hi) *= 268435456.0;\n"
                                "        (*lo) *= 268435456.0;\n"
                                "    } else {\n"
                                "        temp = _QD_SPLITTER * a;\n"
                                "        (*hi) = temp - (temp - a);\n"
                                "        (*lo) = a - (*hi);\n"
                                "    }\n"
                                "}\n"
                                "\n"
                                "stype d4_two_prod(stype a, stype b, stype *err) {\n"
                                "    stype a_hi, a_lo, b_hi, b_lo;\n"
                                "    stype p = a * b;\n"
                                "    d4_split(a, &a_hi, &a_lo);\n"
                                "    d4_split(b, &b_hi, &b_lo);\n"
                                "    (*err) = ((a_hi * b_hi - p) + a_hi * b_lo + a_lo * b_hi) + a_lo * b_lo;\n"
                                "    return p;\n"
                                "}\n"
                                "\n"
                                "void d4_three_sum(stype *a, stype *b, stype *c) {\n"
                                "    stype t1, t2, t3;\n"
                                "    t1 = d4_two_sum((*a), (*b), &t2);\n"
                                "    (*a) = d4_two_sum((*c), t1, &t3);\n"
                                "    (*b) = d4_two_sum(t2, t3, c);\n"
                                "}\n"
                                "\n"
                                "void d4_renorm_(stype *c0, stype *c1, stype *c2, stype *c3, stype *c4) {\n"
                                "    stype s0, s1, s2 = 0.0, s3 = 0.0;\n"
                                "\n"
                                "    if (isinf((*c0))) return;\n"
                                "\n"
                                "    s0 = d4_quick_two_sum((*c3), (*c4), c4);\n"
                                "    s0 = d4_quick_two_sum((*c2), s0, c3);\n"
                                "    s0 = d4_quick_two_sum((*c1), s0, c2);\n"
                                "    (*c0) = d4_quick_two_sum((*c0), s0, c1);\n"
                                "\n"
                                "    s0 = (*c0);\n"
                                "    s1 = (*c1);\n"
                                "\n"
                                "    s0 = d4_quick_two_sum((*c0), (*c1), &s1);\n"
                                "    if (s1 != 0.0) {\n"
                                "        s1 = d4_quick_two_sum(s1, (*c2), &s2);\n"
                                "        if (s2 != 0.0) {\n"
                                "            s2 = d4_quick_two_sum(s2, (*c3), &s3);\n"
                                "            if (s3 != 0.0)\n"
                                "                s3 += (*c4);\n"
                                "            else\n"
                                "                s2 += (*c4);\n"
                                "        } else {\n"
                                "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                                "            if (s2 != 0.0)\n"
                                "                s2 = d4_quick_two_sum(s2, (*c4), &s3);\n"
                                "            else\n"
                                "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                                "        }\n"
                                "    } else {\n"
                                "        s0 = d4_quick_two_sum(s0, (*c2), &s1);\n"
                                "        if (s1 != 0.0) {\n"
                                "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                                "            if (s2 != 0.0)\n"
                                "                s2 = d4_quick_two_sum(s2, (*c4), &s3);\n"
                                "            else\n"
                                "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                                "        } else {\n"
                                "            s0 = d4_quick_two_sum(s0, (*c3), &s1);\n"
                                "            if (s1 != 0.0)\n"
                                "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                                "            else\n"
                                "                s0 = d4_quick_two_sum(s0, (*c4), &s1);\n"
                                "        }\n"
                                "    }\n"
                                "\n"
                                "    (*c0) = s0;\n"
                                "    (*c1) = s1;\n"
                                "    (*c2) = s2;\n"
                                "    (*c3) = s3;\n"
                                "}\n"
                                "\n"
                                "void d4_mul(d4_Type *a, __global d4_Type *b, __global d4_Type *ret) {\n"
                                "    stype p0, p1, p2, p3, p4, p5;\n"
                                "    stype q0, q1, q2, q3, q4, q5;\n"
                                "    stype p6, p7, p8, p9;\n"
                                "    stype q6, q7, q8, q9;\n"
                                "    stype r0, r1;\n"
                                "    stype t0, t1;\n"
                                "    stype s0, s1, s2;\n"
                                "\n"
                                "    p0 = d4_two_prod(a->x[0], b->x[0], &q0);\n"
                                "\n"
                                "    p1 = d4_two_prod(a->x[0], b->x[1], &q1);\n"
                                "    p2 = d4_two_prod(a->x[1], b->x[0], &q2);\n"
                                "\n"
                                "    p3 = d4_two_prod(a->x[0], b->x[2], &q3);\n"
                                "    p4 = d4_two_prod(a->x[1], b->x[1], &q4);\n"
                                "    p5 = d4_two_prod(a->x[2], b->x[0], &q5);\n"
                                "\n"
                                "    d4_three_sum(&p1, &p2, &q0);\n"
                                "\n"
                                "    d4_three_sum(&p2, &q1, &q2);\n"
                                "    d4_three_sum(&p3, &p4, &p5);\n"
                                "\n"
                                "    s0 = d4_two_sum(p2, p3, &t0);\n"
                                "    s1 = d4_two_sum(q1, p4, &t1);\n"
                                "    s2 = q2 + p5;\n"
                                "    s1 = d4_two_sum(s1, t0, &t0);\n"
                                "    s2 += (t0 + t1);\n"
                                "\n"
                                "    p6 = d4_two_prod(a->x[0], b->x[3], &q6);\n"
                                "    p7 = d4_two_prod(a->x[1], b->x[2], &q7);\n"
                                "    p8 = d4_two_prod(a->x[2], b->x[1], &q8);\n"
                                "    p9 = d4_two_prod(a->x[3], b->x[0], &q9);\n"
                                "\n"
                                "    q0 = d4_two_sum(q0, q3, &q3);\n"
                                "    q4 = d4_two_sum(q4, q5, &q5);\n"
                                "    p6 = d4_two_sum(p6, p7, &p7);\n"
                                "    p8 = d4_two_sum(p8, p9, &p9);\n"
                                "\n"
                                "    t0 = d4_two_sum(q0, q4, &t1);\n"
                                "    t1 += (q3 + q5);\n"
                                "\n"
                                "    r0 = d4_two_sum(p6, p8, &r1);\n"
                                "    r1 += (p7 + p9);\n"
                                "\n"
                                "    q3 = d4_two_sum(t0, r0, &q4);\n"
                                "    q4 += (t1 + r1);\n"
                                "\n"
                                "    t0 = d4_two_sum(q3, s1, &t1);\n"
                                "    t1 += q4;\n"
                                "\n"
                                "    t1 += a->x[1] * b->x[3] + a->x[2] * b->x[2] + a->x[3] * b->x[1] + q6 + q7 + q8 + q9 + s2;\n"
                                "\n"
                                "    d4_renorm_(&p0, &p1, &s0, &t0, &t1);\n"
                                "    ret->x[0] = p0;\n"
                                "    ret->x[1] = p1;\n"
                                "    ret->x[2] = s0;\n"
                                "    ret->x[3] = t0;\n"
                                "}\n"
                                "\n"
                                "void d4_mul_w(d4_Type *a, __global d4_Type *b, d4_Type *ret) {\n"
                                "    stype p0, p1, p2, p3, p4, p5;\n"
                                "    stype q0, q1, q2, q3, q4, q5;\n"
                                "    stype p6, p7, p8, p9;\n"
                                "    stype q6, q7, q8, q9;\n"
                                "    stype r0, r1;\n"
                                "    stype t0, t1;\n"
                                "    stype s0, s1, s2;\n"
                                "\n"
                                "    p0 = d4_two_prod(a->x[0], b->x[0], &q0);\n"
                                "\n"
                                "    p1 = d4_two_prod(a->x[0], b->x[1], &q1);\n"
                                "    p2 = d4_two_prod(a->x[1], b->x[0], &q2);\n"
                                "\n"
                                "    p3 = d4_two_prod(a->x[0], b->x[2], &q3);\n"
                                "    p4 = d4_two_prod(a->x[1], b->x[1], &q4);\n"
                                "    p5 = d4_two_prod(a->x[2], b->x[0], &q5);\n"
                                "\n"
                                "    d4_three_sum(&p1, &p2, &q0);\n"
                                "\n"
                                "    d4_three_sum(&p2, &q1, &q2);\n"
                                "    d4_three_sum(&p3, &p4, &p5);\n"
                                "\n"
                                "    s0 = d4_two_sum(p2, p3, &t0);\n"
                                "    s1 = d4_two_sum(q1, p4, &t1);\n"
                                "    s2 = q2 + p5;\n"
                                "    s1 = d4_two_sum(s1, t0, &t0);\n"
                                "    s2 += (t0 + t1);\n"
                                "\n"
                                "    p6 = d4_two_prod(a->x[0], b->x[3], &q6);\n"
                                "    p7 = d4_two_prod(a->x[1], b->x[2], &q7);\n"
                                "    p8 = d4_two_prod(a->x[2], b->x[1], &q8);\n"
                                "    p9 = d4_two_prod(a->x[3], b->x[0], &q9);\n"
                                "\n"
                                "    q0 = d4_two_sum(q0, q3, &q3);\n"
                                "    q4 = d4_two_sum(q4, q5, &q5);\n"
                                "    p6 = d4_two_sum(p6, p7, &p7);\n"
                                "    p8 = d4_two_sum(p8, p9, &p9);\n"
                                "\n"
                                "    t0 = d4_two_sum(q0, q4, &t1);\n"
                                "    t1 += (q3 + q5);\n"
                                "\n"
                                "    r0 = d4_two_sum(p6, p8, &r1);\n"
                                "    r1 += (p7 + p9);\n"
                                "\n"
                                "    q3 = d4_two_sum(t0, r0, &q4);\n"
                                "    q4 += (t1 + r1);\n"
                                "\n"
                                "    t0 = d4_two_sum(q3, s1, &t1);\n"
                                "    t1 += q4;\n"
                                "\n"
                                "    t1 += a->x[1] * b->x[3] + a->x[2] * b->x[2] + a->x[3] * b->x[1] + q6 + q7 + q8 + q9 + s2;\n"
                                "\n"
                                "    d4_renorm_(&p0, &p1, &s0, &t0, &t1);\n"
                                "    ret->x[0] = p0;\n"
                                "    ret->x[1] = p1;\n"
                                "    ret->x[2] = s0;\n"
                                "    ret->x[3] = t0;\n"
                                "}\n"
                                "\n"
                                "void d4_mul_w_(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                                "    stype p0, p1, p2, p3, p4, p5;\n"
                                "    stype q0, q1, q2, q3, q4, q5;\n"
                                "    stype p6, p7, p8, p9;\n"
                                "    stype q6, q7, q8, q9;\n"
                                "    stype r0, r1;\n"
                                "    stype t0, t1;\n"
                                "    stype s0, s1, s2;\n"
                                "\n"
                                "    p0 = d4_two_prod(a->x[0], b->x[0], &q0);\n"
                                "\n"
                                "    p1 = d4_two_prod(a->x[0], b->x[1], &q1);\n"
                                "    p2 = d4_two_prod(a->x[1], b->x[0], &q2);\n"
                                "\n"
                                "    p3 = d4_two_prod(a->x[0], b->x[2], &q3);\n"
                                "    p4 = d4_two_prod(a->x[1], b->x[1], &q4);\n"
                                "    p5 = d4_two_prod(a->x[2], b->x[0], &q5);\n"
                                "\n"
                                "    d4_three_sum(&p1, &p2, &q0);\n"
                                "\n"
                                "    d4_three_sum(&p2, &q1, &q2);\n"
                                "    d4_three_sum(&p3, &p4, &p5);\n"
                                "\n"
                                "    s0 = d4_two_sum(p2, p3, &t0);\n"
                                "    s1 = d4_two_sum(q1, p4, &t1);\n"
                                "    s2 = q2 + p5;\n"
                                "    s1 = d4_two_sum(s1, t0, &t0);\n"
                                "    s2 += (t0 + t1);\n"
                                "\n"
                                "    p6 = d4_two_prod(a->x[0], b->x[3], &q6);\n"
                                "    p7 = d4_two_prod(a->x[1], b->x[2], &q7);\n"
                                "    p8 = d4_two_prod(a->x[2], b->x[1], &q8);\n"
                                "    p9 = d4_two_prod(a->x[3], b->x[0], &q9);\n"
                                "\n"
                                "    q0 = d4_two_sum(q0, q3, &q3);\n"
                                "    q4 = d4_two_sum(q4, q5, &q5);\n"
                                "    p6 = d4_two_sum(p6, p7, &p7);\n"
                                "    p8 = d4_two_sum(p8, p9, &p9);\n"
                                "\n"
                                "    t0 = d4_two_sum(q0, q4, &t1);\n"
                                "    t1 += (q3 + q5);\n"
                                "\n"
                                "    r0 = d4_two_sum(p6, p8, &r1);\n"
                                "    r1 += (p7 + p9);\n"
                                "\n"
                                "    q3 = d4_two_sum(t0, r0, &q4);\n"
                                "    q4 += (t1 + r1);\n"
                                "\n"
                                "    t0 = d4_two_sum(q3, s1, &t1);\n"
                                "    t1 += q4;\n"
                                "\n"
                                "    t1 += a->x[1] * b->x[3] + a->x[2] * b->x[2] + a->x[3] * b->x[1] + q6 + q7 + q8 + q9 + s2;\n"
                                "\n"
                                "    d4_renorm_(&p0, &p1, &s0, &t0, &t1);\n"
                                "    ret->x[0] = p0;\n"
                                "    ret->x[1] = p1;\n"
                                "    ret->x[2] = s0;\n"
                                "    ret->x[3] = t0;\n"
                                "}\n"
                                "\n"
                                "void d4_minus(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                                "    d4_Type c;\n"
                                "    d4_neg(b, &c);\n"
                                "    d4_Type d;\n"
                                "    d4_add(a, &c, &d);\n"
                                "    d4_assign(ret, &d);\n"
                                "}\n"
                                "\n"
                                "void d4_three_sum2(stype *a, stype *b, stype *c) {\n"
                                "    stype t1, t2, t3;\n"
                                "    t1 = d4_two_sum((*a), (*b), &t2);\n"
                                "    (*a) = d4_two_sum((*c), t1, &t3);\n"
                                "    (*b) = t2 + t3;\n"
                                "}\n"
                                "\n"
                                "void d4_mul_qd_d(d4_Type *a, stype b, d4_Type *ret) {\n"
                                "    stype p0, p1, p2, p3;\n"
                                "    stype q0, q1, q2;\n"
                                "    stype s0, s1, s2, s3, s4;\n"
                                "\n"
                                "    p0 = d4_two_prod(a->x[0], b, &q0);\n"
                                "    p1 = d4_two_prod(a->x[1], b, &q1);\n"
                                "    p2 = d4_two_prod(a->x[2], b, &q2);\n"
                                "    p3 = a->x[3] * b;\n"
                                "\n"
                                "    s0 = p0;\n"
                                "\n"
                                "    s1 = d4_two_sum(q0, p1, &s2);\n"
                                "\n"
                                "    d4_three_sum(&s2, &q1, &p2);\n"
                                "\n"
                                "    d4_three_sum2(&q1, &q2, &p3);\n"
                                "    s3 = q1;\n"
                                "\n"
                                "    s4 = q2 + p2;\n"
                                "\n"
                                "    d4_renorm_(&s0, &s1, &s2, &s3, &s4);\n"
                                "    new_d4(s0, s1, s2, s3, ret);\n"
                                "}\n"
                                "\n"
                                "void d4_div(__global d4_Type *a, d4_Type *b, __global d4_Type *ret) {\n"
                                "    stype q0, q1, q2, q3;\n"
                                "\n"
                                "    d4_Type r, tmp, tmp_a;\n"
                                "\n"
                                "    q0 = a->x[0] / b->x[0];\n"
                                "    tmp_a.x[0] = a->x[0];\n"
                                "    tmp_a.x[1] = a->x[1];\n"
                                "    tmp_a.x[2] = a->x[2];\n"
                                "    tmp_a.x[3] = a->x[3];\n"
                                "    d4_mul_qd_d(b, q0, &tmp);\n"
                                "    d4_minus(&tmp_a, &tmp, &r);\n"
                                "\n"
                                "    q1 = r.x[0] / b->x[0];\n"
                                "    d4_mul_qd_d(b, q1, &tmp);\n"
                                "    d4_minus(&r, &tmp, &r);\n"
                                "\n"
                                "    q2 = r.x[0] / b->x[0];\n"
                                "    d4_mul_qd_d(b, q2, &tmp);\n"
                                "    d4_minus(&r, &tmp, &r);\n"
                                "\n"
                                "    q3 = r.x[0] / b->x[0];\n"
                                "    d4_mul_qd_d(b, q3, &tmp);\n"
                                "    d4_minus(&r, &tmp, &r);\n"
                                "\n"
                                "    stype q4 = r.x[0] / b->x[0];\n"
                                "\n"
                                "    d4_renorm_(&q0, &q1, &q2, &q3, &q4);\n"
                                "\n"
                                "    new_d4_(q0, q1, q2, q3, ret);\n"
                                "}\n"
                                "\n"
                                "void d4_assign(d4_Type *a, d4_Type *b) {\n"
                                "    a->x[0] = b->x[0];\n"
                                "    a->x[1] = b->x[1];\n"
                                "    a->x[2] = b->x[2];\n"
                                "    a->x[3] = b->x[3];\n"
                                "}\n"
                                "\n"
                                "\n"
                                "void d4_assign_(__global d4_Type *a, d4_Type *b) {\n"
                                "    a->x[0] = b->x[0];\n"
                                "    a->x[1] = b->x[1];\n"
                                "    a->x[2] = b->x[2];\n"
                                "    a->x[3] = b->x[3];\n"
                                "}");
#endif