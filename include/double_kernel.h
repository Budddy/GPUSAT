#ifndef GPUSAT_DOUBLE_KERNEL_H
#define GPUSAT_DOUBLE_KERNEL_H

#include <string>

std::string inc_kernel("#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
                               "#define stype double\n"
                               "\n"
                               "int isNotSat(unsigned long assignment, __global long *clause, __global unsigned long *variables);\n"
                               "\n"
                               "/**\n"
                               " * Operation to solve a Join node in the decomposition.\n"
                               " *\n"
                               " * @param nSol\n"
                               " *      array containing the number of solutions for each assignment for the current node\n"
                               " * @param e1Sol\n"
                               " *      array containing the number of solutions for each assignment for the first edge\n"
                               " * @param e2Sol\n"
                               " *      array containing the number of solutions for each assignment for the second edge\n"
                               " * @param minIDe1\n"
                               " *      min id of the first edge\n"
                               " * @param maxIDe1\n"
                               " *      max id of the first edge\n"
                               " * @param minIDe2\n"
                               " *      min id of the second edge\n"
                               " * @param maxIDe2\n"
                               " *      max id of the second edge\n"
                               " * @param startIDn\n"
                               " *      start id of the current node\n"
                               " * @param startIDe1\n"
                               " *      start id of the first edge\n"
                               " * @param startIDe2\n"
                               " *      of the second edge\n"
                               " * @param numClauses\n"
                               " *      number of clauses in the current node\n"
                               " */\n"
                               "__kernel void solveJoin(__global stype *nSol, __global stype *e1Sol, __global stype *e2Sol,\n"
                               "                        unsigned long minIDe1, unsigned long maxIDe1,\n"
                               "                        unsigned long minIDe2, unsigned long maxIDe2,\n"
                               "                        unsigned long startIDn, unsigned long startIDe1, unsigned long startIDe2,\n"
                               "                        unsigned long numClauses,\n"
                               "                        __global double *weights, __global unsigned long *nVars, __global int *sols) {\n"
                               "    unsigned long combinations = ((unsigned long) exp2((double) numClauses));\n"
                               "    unsigned long start2 = 0, end2 = combinations - 1;\n"
                               "\n"
                               "    unsigned long id = get_global_id(0);\n"
                               "    unsigned long mask = id & (((unsigned long) exp2((double) numClauses)) - 1);\n"
                               "    unsigned long templateID = id >> numClauses << numClauses;\n"
                               "    double tmpSol = 0;\n"
                               "    //sum up the solution count for all subsets of Clauses (A1,A2) where the intersection of A1 and A2 = A\n"
                               "    for (; start2 < (combinations - 1) && e2Sol[(templateID | start2) - (startIDe2)] == 0; start2++);\n"
                               "    for (; end2 > 0 && e2Sol[(templateID | end2) - (startIDe2)] == 0; end2--);\n"
                               "    for (int a = 0; a < combinations; a++) {\n"
                               "        if ((templateID | a) >= minIDe1 && (templateID | a) < maxIDe1 && e1Sol[(templateID | a) - (startIDe1)] != 0) {\n"
                               "            for (int b = start2; b <= end2; b++) {\n"
                               "                if (((a | b)) == mask && ((templateID | b) >= minIDe2 && (templateID | b) < maxIDe2) && e2Sol[(templateID | b) - (startIDe2)] != 0) {\n"
                               "                    tmpSol += e1Sol[(templateID | a) - (startIDe1)] * e2Sol[(templateID | b) - (startIDe2)];\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    if (tmpSol != 0.0) {\n"
                               "        if (weights != 0) {\n"
                               "            double weight = 1;\n"
                               "            unsigned long assignment = id >> numClauses;\n"
                               "            for (int a = 0; nVars[a] != 0; a++) {\n"
                               "                weight *= weights[((assignment >> a) & 1) > 0 ? nVars[a] * 2 : nVars[a] * 2 + 1];\n"
                               "            }\n"
                               "            nSol[id - (startIDn)] += tmpSol / weight;\n"
                               "        } else {\n"
                               "            nSol[id - (startIDn)] += tmpSol;\n"
                               "        }\n"
                               "    }\n"
                               "    if (nSol[id - (startIDn)] > 0) {\n"
                               "        *sols = 1;\n"
                               "    }\n"
                               "}\n"
                               "\n"
                               "/**\n"
                               " * Operation to solve a Introduce node in the decomposition.\n"
                               " *\n"
                               " * @param nSol\n"
                               " *      array containing the number of solutions for each assignment for the current node\n"
                               " * @param eSol\n"
                               " *      array containing the number of solutions for each assignment for the edge\n"
                               " * @param clauses\n"
                               " *      array containing the clauses of the current node, negated atoms are negative\n"
                               " * @param cLen\n"
                               " *      length of the clauses array\n"
                               " * @param nVars\n"
                               " *      array containing the ids of the variables in the current node\n"
                               " * @param eVars\n"
                               " *      array containing the ids of the variables in the edge\n"
                               " * @param numNV\n"
                               " *      number of variables in the current node\n"
                               " * @param numEV\n"
                               " *      number of variables in the edge\n"
                               " * @param nClauses\n"
                               " *      array containing the clause ids of the current node\n"
                               " * @param eClauses\n"
                               " *      array containing the clause ids of the edge\n"
                               " * @param numNC\n"
                               " *      number of clauses in the current node\n"
                               " * @param numEC\n"
                               " *      number of clauses in the edge\n"
                               " * @param startIDn\n"
                               " *      start id of the current node\n"
                               " * @param startIDe\n"
                               " *      start id of the edge\n"
                               " * @param minID\n"
                               " *      min id of the edge\n"
                               " * @param maxID\n"
                               " *      max id of the edge\n"
                               " */\n"
                               "__kernel void solveIntroduce(__global stype *nSol, __global stype *eSol,\n"
                               "                             __global long *clauses, unsigned long cLen,\n"
                               "                             __global unsigned long *nVars, __global unsigned long *eVars,\n"
                               "                             unsigned long numNV, unsigned long numEV,\n"
                               "                             __global unsigned long *nClauses, __global unsigned long *eClauses,\n"
                               "                             unsigned long numNC, unsigned long numEC,\n"
                               "                             unsigned long startIDn, unsigned long startIDe,\n"
                               "                             unsigned long minIDe, unsigned long maxIDe, __global double *weights, __global int *sols) {\n"
                               "    unsigned long id = get_global_id(0);\n"
                               "    unsigned long assignment = id >> numNC, templateID = 0;\n"
                               "    unsigned long a = 0, b = 0, c = 0, i = 0, notSAT = 0, base = 0;\n"
                               "    //check clauses\n"
                               "    for (a = 0, b = 0, i = 0; a < numNC; i++) {\n"
                               "        if (i == 0 || clauses[i] == 0) {\n"
                               "            if (clauses[i] == 0) i++;\n"
                               "            if (nClauses[a] == eClauses[b]) {\n"
                               "                b++;\n"
                               "            } else if (isNotSat(assignment, &clauses[i], nVars) == ((id >> a) & 1)) {\n"
                               "                nSol[id - startIDn] = 0.0;\n"
                               "                return;\n"
                               "            }\n"
                               "            a++;\n"
                               "        }\n"
                               "    }\n"
                               "    unsigned long d = 0;\n"
                               "    int baseSum = 0;\n"
                               "    //check variables\n"
                               "    for (i = 0, c = 0; i < cLen; i++) {\n"
                               "        if (clauses[i] == 0) {\n"
                               "            baseSum = 0;\n"
                               "            if (nClauses[c] == eClauses[d]) {\n"
                               "                d++;\n"
                               "            }\n"
                               "            c++;\n"
                               "        } else {\n"
                               "            for (a = 0; a < numNV; a++) {\n"
                               "                if ((((id >> c) & 1) == 0) && (clauses[i] == nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                    nSol[id - startIDn] = 0.0;\n"
                               "                    return;\n"
                               "                }\n"
                               "                if ((baseSum == 0) && (nClauses[c] == eClauses[d]) && (((id >> c) & 1) == 1) &&\n"
                               "                    (clauses[i] == nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                    base++;\n"
                               "                    baseSum = 1;\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    //generate template variables\n"
                               "    for (b = 0, a = 0; a < numNV; a++) {\n"
                               "        if (nVars[a] == eVars[b]) {\n"
                               "            templateID |= ((id >> (a + numNC)) & 1) << (b + numEC);\n"
                               "            b++;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    //generate template clauses\n"
                               "    for (b = 0, a = 0; a < numNC; a++) {\n"
                               "        if (nClauses[a] == eClauses[b]) {\n"
                               "            templateID |= ((id >> a) & 1) << b;\n"
                               "            b++;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    unsigned long combinations = (unsigned long) exp2((double) base);\n"
                               "    unsigned long otherID = templateID, nc = 0, ec = 0, x = 0, index = 0, rec;\n"
                               "\n"
                               "    double weight = 1;\n"
                               "\n"
                               "    if (weights != 0) {\n"
                               "        for (b = 0, a = 0; nVars[a] != 0; a++) {\n"
                               "            if ((nVars[a] != eVars[b])) {\n"
                               "                weight *= weights[((assignment >> a) & 1) > 0 ? nVars[a] * 2 : nVars[a] * 2 + 1];\n"
                               "            }\n"
                               "            if (nVars[a] == eVars[b] && eVars[b] != 0) {\n"
                               "                b++;\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    stype tmp = 0;\n"
                               "    if (numNV != numEV) {\n"
                               "        for (i = 0, c = 0; i < combinations; i++) {\n"
                               "            otherID = templateID;\n"
                               "            index = 0;\n"
                               "\n"
                               "            for (ec = 0, nc = 0, x = 0; nc < numNC; nc++, x++) {\n"
                               "                rec = 0;\n"
                               "                if (eClauses[ec] == nClauses[nc]) {\n"
                               "                    for (; clauses[x] != 0; x++) {\n"
                               "                        for (a = 0, b = 0; a < numNV && rec == 0; a++) {\n"
                               "                            if (clauses[x] == (nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                                otherID &= ~(((i >> index) & 1) << ec);\n"
                               "                                index++;\n"
                               "                                rec = 1;\n"
                               "                            }\n"
                               "                            if (nVars[a] == eVars[b]) {\n"
                               "                                b++;\n"
                               "                            } else {\n"
                               "                            }\n"
                               "                        }\n"
                               "                    }\n"
                               "                    ec++;\n"
                               "                } else {\n"
                               "                    for (; clauses[x] != 0; x++);\n"
                               "                }\n"
                               "            }\n"
                               "\n"
                               "            if (otherID >= (minIDe) && otherID < (maxIDe)) {\n"
                               "                tmp += eSol[otherID - (startIDe)];\n"
                               "            }\n"
                               "        }\n"
                               "    } else {\n"
                               "        if (otherID >= (minIDe) && otherID < (maxIDe)) {\n"
                               "            tmp += eSol[otherID - (startIDe)];\n"
                               "        }\n"
                               "    }\n"
                               "    nSol[id - (startIDn)] += tmp * weight;\n"
                               "    if (nSol[id - (startIDn)] > 0) {\n"
                               "        *sols = 1;\n"
                               "    }\n"
                               "\n"
                               "}\n"
                               "\n"
                               "//check if Clause is not Satisfiable\n"
                               "int isNotSat(unsigned long assignment, __global long *clause, __global unsigned long *variables) {\n"
                               "    int a = 0, i = 0;\n"
                               "    for (a = 0; variables[a] != 0; a++) {\n"
                               "        for (i = 0; clause[i] != 0; i++) {\n"
                               "            if (clause[i] == variables[a] || clause[i] == -variables[a]) {\n"
                               "                if ((clause[i] > 0 && ((assignment >> a) & 1) == 1) ||\n"
                               "                    (clause[i] < 0 && ((assignment >> a) & 1) == 0)) {\n"
                               "                    return 0;\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    return 1;\n"
                               "}\n"
                               "\n"
                               "/**\n"
                               " * introduce function for the introduce forget operation\n"
                               " *\n"
                               " * @param nSol\n"
                               " *      array containing the number of solutions for each assignment for the current node\n"
                               " * @param eSol\n"
                               " *      array containing the number of solutions for each assignment for the edge\n"
                               " * @param clauses\n"
                               " *      array containing the clauses of the current node, negated atoms are negative\n"
                               " * @param cLen\n"
                               " *      length of the clauses array\n"
                               " * @param nVars\n"
                               " *      array containing the ids of the variables in the current node\n"
                               " * @param eVars\n"
                               " *      array containing the ids of the variables in the edge\n"
                               " * @param numNV\n"
                               " *      number of variables in the current node\n"
                               " * @param numEV\n"
                               " *      number of variables in the edge\n"
                               " * @param nClauses\n"
                               " *      array containing the clause ids of the current node\n"
                               " * @param eClauses\n"
                               " *      array containing the clause ids of the edge\n"
                               " * @param numNC\n"
                               " *      number of clauses in the current node\n"
                               " * @param numEC\n"
                               " *      number of clauses in the edge\n"
                               " * @param startIDe\n"
                               " *      start id of the edge\n"
                               " * @param minIDe\n"
                               " *      min id of the edge\n"
                               " * @param maxIDe\n"
                               " *      max id of the edge\n"
                               " */\n"
                               "stype solveIntroduceF(__global stype *eSol,\n"
                               "                      __global long *clauses, unsigned long cLen,\n"
                               "                      __global unsigned long *nVars, __global unsigned long *eVars,\n"
                               "                      unsigned long numNV, unsigned long numEV,\n"
                               "                      __global unsigned long *nClauses, __global unsigned long *eClauses,\n"
                               "                      unsigned long numNC, unsigned long numEC,\n"
                               "                      unsigned long startIDe,\n"
                               "                      unsigned long minIDe, unsigned long maxIDe, __global double *weights,\n"
                               "                      long id) {\n"
                               "    unsigned long assignment = id >> numNC, templateID = 0;\n"
                               "    unsigned long a = 0, b = 0, c = 0, i = 0, notSAT = 0, base = 0;\n"
                               "    //check clauses\n"
                               "    for (a = 0, b = 0, i = 0; a < numNC; i++) {\n"
                               "        if (i == 0 || clauses[i] == 0) {\n"
                               "            if (clauses[i] == 0) i++;\n"
                               "            if (nClauses[a] == eClauses[b]) {\n"
                               "                b++;\n"
                               "            } else if (isNotSat(assignment, &clauses[i], nVars) == ((id >> a) & 1)) {\n"
                               "                return 0.0;\n"
                               "            }\n"
                               "            a++;\n"
                               "        }\n"
                               "    }\n"
                               "    unsigned long d = 0;\n"
                               "    int baseSum = 0;\n"
                               "    //check variables\n"
                               "    for (i = 0, c = 0; i < cLen; i++) {\n"
                               "        if (clauses[i] == 0) {\n"
                               "            baseSum = 0;\n"
                               "            if (nClauses[c] == eClauses[d]) {\n"
                               "                d++;\n"
                               "            }\n"
                               "            c++;\n"
                               "        } else {\n"
                               "            for (a = 0; a < numNV; a++) {\n"
                               "                if ((((id >> c) & 1) == 0) && (clauses[i] == nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                    return 0.0;\n"
                               "                }\n"
                               "                if ((baseSum == 0) && (nClauses[c] == eClauses[d]) && (((id >> c) & 1) == 1) &&\n"
                               "                    (clauses[i] == nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                    base++;\n"
                               "                    baseSum = 1;\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    //template variables\n"
                               "    for (b = 0, a = 0; a < numNV; a++) {\n"
                               "        if (nVars[a] == eVars[b]) {\n"
                               "            templateID |= ((id >> (a + numNC)) & 1) << (b + numEC);\n"
                               "            b++;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    //template clauses\n"
                               "    for (b = 0, a = 0; a < numNC; a++) {\n"
                               "        if (nClauses[a] == eClauses[b]) {\n"
                               "            templateID |= ((id >> a) & 1) << b;\n"
                               "            b++;\n"
                               "        }\n"
                               "    }\n"
                               "\n"
                               "    unsigned long combinations = (unsigned long) exp2((double) base);\n"
                               "    unsigned long otherID = templateID, nc = 0, ec = 0, x = 0, index = 0, rec;\n"
                               "\n"
                               "    double weight = 1;\n"
                               "\n"
                               "    if (weights != 0) {\n"
                               "        for (b = 0, a = 0; nVars[a] != 0; a++) {\n"
                               "            if ((nVars[a] != eVars[b])) {\n"
                               "                weight *= weights[((assignment >> a) & 1) > 0 ? nVars[a] * 2 : nVars[a] * 2 + 1];\n"
                               "            }\n"
                               "            if (nVars[a] == eVars[b] && eVars[b] != 0) {\n"
                               "                b++;\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    stype tmp = 0.0;\n"
                               "    if (numNV != numEV) {\n"
                               "        for (i = 0, c = 0; i < combinations; i++) {\n"
                               "            otherID = templateID;\n"
                               "            index = 0;\n"
                               "\n"
                               "            for (ec = 0, nc = 0, x = 0; nc < numNC; nc++, x++) {\n"
                               "                rec = 0;\n"
                               "                if (eClauses[ec] == nClauses[nc]) {\n"
                               "                    for (; clauses[x] != 0; x++) {\n"
                               "                        for (a = 0, b = 0; a < numNV && rec == 0; a++) {\n"
                               "                            if (clauses[x] == (nVars[a] * (((assignment >> a) & 1) > 0 ? 1 : -1))) {\n"
                               "                                otherID &= ~(((i >> index) & 1) << ec);\n"
                               "                                index++;\n"
                               "                                rec = 1;\n"
                               "                            }\n"
                               "                            if (nVars[a] == eVars[b]) {\n"
                               "                                b++;\n"
                               "                            } else {\n"
                               "                            }\n"
                               "                        }\n"
                               "                    }\n"
                               "                    ec++;\n"
                               "                } else {\n"
                               "                    for (; clauses[x] != 0; x++);\n"
                               "                }\n"
                               "            }\n"
                               "\n"
                               "            if (otherID >= minIDe && otherID < maxIDe) {\n"
                               "                if (eSol != 0) {\n"
                               "                    tmp += eSol[otherID - startIDe];\n"
                               "                } else {\n"
                               "                    tmp += 1.0;\n"
                               "                }\n"
                               "            }\n"
                               "        }\n"
                               "    } else {\n"
                               "        if (otherID >= minIDe && otherID < maxIDe) {\n"
                               "            if (eSol != 0) {\n"
                               "                tmp += eSol[otherID - startIDe];\n"
                               "            } else {\n"
                               "                tmp += 1.0;\n"
                               "            }\n"
                               "        }\n"
                               "    }\n"
                               "    tmp *= weight;\n"
                               "    return tmp;\n"
                               "}\n"
                               "\n"
                               "/**\n"
                               " * combination of the introduce and forget operation\n"
                               " *\n"
                               " * @param solsF\n"
                               " *      array containing the number of solutions for each assignment for the current node\n"
                               " * @param solsE\n"
                               " *      array containing the number of solutions for each assignment for the edge\n"
                               " * @param varsF\n"
                               " *      array containing the ids of the variables in the current node\n"
                               " * @param varsE\n"
                               " *      array containing the ids of the variables in the edge node\n"
                               " * @param numVF\n"
                               " *      the number of variables in the current node\n"
                               " * @param numVE\n"
                               " *      the number of variables in the edge node\n"
                               " * @param fClauses\n"
                               " *      array containing the clause ids of the current node\n"
                               " * @param eClauses\n"
                               " *      array containing the clause ids of the edge node\n"
                               " * @param numCF\n"
                               " *      number of clauses in the current node\n"
                               " * @param numCE\n"
                               " *      number of clauses in the edge node\n"
                               " * @param startIDf\n"
                               " *      start id of the current node\n"
                               " * @param startIDe\n"
                               " *      start id of the edge node\n"
                               " * @param minIDE\n"
                               " *      min id of the edge\n"
                               " * @param maxIDE\n"
                               " *      max id of the edge\n"
                               " * @param sols\n"
                               " *      flag, indicating that there are solutions in the current bag\n"
                               " * @param varsI\n"
                               " *      array containing the ids of the variables in the introduce node\n"
                               " * @param numVI\n"
                               " *      array containing the number of variables in the introduce node\n"
                               " * @param iClauses\n"
                               " *      array containing the clause ids of the introduce node\n"
                               " * @param numCI\n"
                               " *      number of clauses in the introduce node\n"
                               " * @param clauses\n"
                               " *      array containing the clauses of the current node, negated atoms are negative\n"
                               " * @param cLen\n"
                               " *      length of the clauses array\n"
                               " * @param weights\n"
                               " *      array containing the weights of each variable\n"
                               " */\n"
                               "__kernel void solveIntroduceForget(__global stype *solsF, __global stype *solsE,\n"
                               "                                   __global unsigned long *varsF, __global unsigned long *varsE,\n"
                               "                                   unsigned long numVF, unsigned long numVE,\n"
                               "                                   __global unsigned long *fClauses, __global unsigned long *eClauses,\n"
                               "                                   unsigned long numCF, unsigned long numCE,\n"
                               "                                   unsigned long startIDf, unsigned long startIDe,\n"
                               "                                   unsigned long minIDE, unsigned long maxIDE, __global int *sols,\n"
                               "                                   __global unsigned long *varsI, unsigned long numVI, __global unsigned long *iClauses, unsigned long numCI,\n"
                               "                                   __global long *clauses, unsigned long cLen, __global double *weights) {\n"
                               "    unsigned long id = get_global_id(0);\n"
                               "    unsigned long a = 0, b = 0, templateId = 0, i = 0;\n"
                               "    unsigned long combinations = (unsigned long) exp2((double) numVI - numVF);\n"
                               "    if (numVI != numVF || numCI != numCF) {\n"
                               "        //generate template clauses\n"
                               "        for (a = 0, b = 0; a < numCI; a++) {\n"
                               "            if (fClauses[b] == iClauses[a]) {\n"
                               "                templateId = templateId | (((id >> b) & 1) << a);\n"
                               "                b++;\n"
                               "            } else {\n"
                               "                templateId = templateId | (1 << a);\n"
                               "            }\n"
                               "        }\n"
                               "        //generate template variables\n"
                               "        for (a = 0, b = 0; a < numVI && b < numVF; a++) {\n"
                               "            if (varsF[b] == varsI[a]) {\n"
                               "                templateId = templateId | (((id >> (b + numCF)) & 1) << (a + numCI));\n"
                               "                b++;\n"
                               "            }\n"
                               "        }\n"
                               "\n"
                               "        // iterate through all corresponding assignments in the edge\n"
                               "        for (i = 0; i < combinations; i++) {\n"
                               "            long b = 0, otherId = templateId;\n"
                               "            for (a = 0; a < numVI; a++) {\n"
                               "                if (b >= numVF || varsI[a] != varsF[b]) {\n"
                               "                    otherId = otherId | (((i >> (a - b)) & 1) << (a + numCI));\n"
                               "                } else {\n"
                               "                    b++;\n"
                               "                }\n"
                               "            }\n"
                               "            // get solution count from edge\n"
                               "            solsF[id - (startIDf)] += solveIntroduceF(solsE, clauses, cLen, varsI, varsE, numVI, numVE, iClauses, eClauses, numCI, numCE, startIDe, minIDE, maxIDE,\n"
                               "                                                      weights, otherId);\n"
                               "        }\n"
                               "    } else {\n"
                               "        // only solve introduce if there is no forget\n"
                               "        solsF[id - (startIDf)] += solveIntroduceF(solsE, clauses, cLen, varsI, varsE, numVI, numVE, iClauses, eClauses, numCI, numCE, startIDe, minIDE, maxIDE,\n"
                               "                                                  weights, id);\n"
                               "    }\n"
                               "    if (solsF[id - (startIDf)] > 0) {\n"
                               "        *sols = 1;\n"
                               "    }\n"
                               "}");

std::string prim_kernel("#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
                                "#define stype double\n"
                                "//#define __global\n"
                                "//#define __kernel\n"
                                "\n"
                                "/**\n"
                                " * Operation to solve a Introduce node in the decomposition.\n"
                                " *\n"
                                " * @param clauses\n"
                                " *      array containing the clauses in the sat formula\n"
                                " * @param numVarsC\n"
                                " *      array containing the number of variables for each clause\n"
                                " * @param numclauses\n"
                                " *      the number of clauses\n"
                                " * @param solutions\n"
                                " *      array for saving the number of models for each assignment\n"
                                " * @param numV\n"
                                " *      the number of variables in the current bag\n"
                                " * @param edge\n"
                                " *      the number of models for each assignment of the next bag\n"
                                " * @param numVE\n"
                                " *      the number of variables in the next bag\n"
                                " * @param variables\n"
                                " *      the ids of the variables in the current bag\n"
                                " * @param edgeVariables\n"
                                " *      the ids of the variables in the next bag\n"
                                " */\n"
                                "stype solveIntroduce_(long numV, __global stype *edge, long numVE, __global long *variables, __global long *edgeVariables, long minId, long maxId,\n"
                                "                      long startIDEdge, __global double *weights, long id) {\n"
                                "    long otherId = 0;\n"
                                "    long a = 0, b = 0;\n"
                                "    double weight = 1.0;\n"
                                "    for (b = 0; b < numVE && a < numV; b++) {\n"
                                "        while ((variables[a] != edgeVariables[b])) {\n"
                                "            a++;\n"
                                "        }\n"
                                "        otherId = otherId | (((id >> a) & 1) << b);\n"
                                "        a++;\n"
                                "    };\n"
                                "\n"
                                "    //weighted model count\n"
                                "    if (weights != 0) {\n"
                                "        for (b = 0, a = 0; a < numV; a++) {\n"
                                "            if (edgeVariables == 0 || (variables[a] != edgeVariables[b])) {\n"
                                "                weight *= weights[((id >> a) & 1) > 0 ? variables[a] * 2 : variables[a] * 2 + 1];\n"
                                "            }\n"
                                "            if (edgeVariables != 0 && (variables[a] == edgeVariables[b]) && (b < (numVE - 1))) {\n"
                                "                b++;\n"
                                "            }\n"
                                "        }\n"
                                "    }\n"
                                "\n"
                                "    if (edge != 0 && otherId >= (minId) && otherId < (maxId)) {\n"
                                "        return edge[otherId - (startIDEdge)] * weight;\n"
                                "    } else if (edge == 0 && otherId >= (minId) && otherId < (maxId)) {\n"
                                "        return 0.0;\n"
                                "    } else {\n"
                                "        return -1.0;\n"
                                "    }\n"
                                "}\n"
                                "\n"
                                "/**\n"
                                " * Operation to check if an assignment satisfies the clauses of a SAT formula.\n"
                                " *\n"
                                " * @param clauses\n"
                                " *      the clauses in the SAT formula\n"
                                " * @param numVarsC\n"
                                " *      array containing the number of Variables in each clause\n"
                                " * @param numclauses\n"
                                " *      the number of clauses in the sat formula\n"
                                " * @param id\n"
                                " *      the id of the thread - used to get the variable assignment\n"
                                " * @param numV\n"
                                " *      the number of variables\n"
                                " * @param variables\n"
                                " *      a vector containing the ids of the variables\n"
                                " * @return\n"
                                " *      1 - if the assignment satisfies the formula\n"
                                " *      0 - if the assignment doesn't satisfy the formula\n"
                                " */\n"
                                "int checkBag(__global long *clauses, __global long *numVarsC, long numclauses, long id, long numV, __global long *variables) {\n"
                                "    long i, varNum = 0;\n"
                                "    long satC = 0, a, b;\n"
                                "    // iterate through all clauses\n"
                                "    for (i = 0; i < numclauses; i++) {\n"
                                "        satC = 0;\n"
                                "        // iterate through clause variables\n"
                                "        for (a = 0; a < numVarsC[i] && !satC; a++) {\n"
                                "            satC = 1;\n"
                                "            //check current variables\n"
                                "            for (b = 0; b < numV; b++) {\n"
                                "                // check if clause is satisfied\n"
                                "                if ((clauses[varNum + a] == variables[b]) ||\n"
                                "                    (clauses[varNum + a] == -variables[b])) {\n"
                                "                    satC = 0;\n"
                                "                    if (clauses[varNum + a] < 0) {\n"
                                "                        //clause contains negative var and var is assigned negative\n"
                                "                        if ((id & (1 << (b))) == 0) {\n"
                                "                            satC = 1;\n"
                                "                            break;\n"
                                "                        }\n"
                                "                    } else {\n"
                                "                        //clause contains positive var and var is assigned positive\n"
                                "                        if ((id & (1 << (b))) > 0) {\n"
                                "                            satC = 1;\n"
                                "                            break;\n"
                                "                        }\n"
                                "                    }\n"
                                "                }\n"
                                "            }\n"
                                "        }\n"
                                "        varNum += numVarsC[i];\n"
                                "        // we have an unsattisifed clause\n"
                                "        if (!satC) {\n"
                                "            return 0;\n"
                                "        }\n"
                                "    }\n"
                                "    return 1;\n"
                                "}\n"
                                "\n"
                                "/**\n"
                                " * Operation to solve a Join node in the decomposition.\n"
                                " *\n"
                                " * @param solutions\n"
                                " *      array to save the number of solutions of the join\n"
                                " * @param edge1\n"
                                " *      array containing the number of solutions in the first edge\n"
                                " * @param edge2\n"
                                " *      array containing the number of solutions in the second edge\n"
                                " * @param variables\n"
                                " *      the variables in the join bag\n"
                                " * @param edgeVariables1\n"
                                " *      the variables in the bag of the first edge\n"
                                " * @param edgeVariables2\n"
                                " *      the variables in the bag of the second edge\n"
                                " * @param numV\n"
                                " *      the number of variables in the join bag\n"
                                " * @param numVE1\n"
                                " *      the number of variables in the first edge\n"
                                " * @param numVE2\n"
                                " *      the number of variables in the second edge\n"
                                " */\n"
                                "__kernel void solveJoin(__global stype *solutions, __global stype *edge1, __global stype *edge2, __global long *variables, __global long *edgeVariables1,\n"
                                "                        __global long *edgeVariables2, long numV, long numVE1, long numVE2, long minId1, long maxId1, long minId2,\n"
                                "                        long maxId2, long startIDNode, long startIDEdge1, long startIDEdge2, __global double *weights, __global int *sols) {\n"
                                "    long id = get_global_id(0);\n"
                                "    stype tmp = -1, tmp_ = -1;\n"
                                "    double weight = 1;\n"
                                "    // get solution count from first edge\n"
                                "    tmp = solveIntroduce_(numV, edge1, numVE1, variables, edgeVariables1, minId1, maxId1, startIDEdge1, weights, id);\n"
                                "    // get solution count from second edge\n"
                                "    tmp_ = solveIntroduce_(numV, edge2, numVE2, variables, edgeVariables2, minId2, maxId2, startIDEdge2, weights, id);\n"
                                "    // weighted model count\n"
                                "    if (weights != 0) {\n"
                                "        for (int a = 0; a < numV; a++) {\n"
                                "            weight *= weights[((id >> a) & 1) > 0 ? variables[a] * 2 : variables[a] * 2 + 1];\n"
                                "        }\n"
                                "    }\n"
                                "\n"
                                "    // we have some solutions in edge1\n"
                                "    if (tmp >= 0.0) {\n"
                                "        solutions[id - (startIDNode)] *= tmp;\n"
                                "        solutions[id - (startIDNode)] /= weight;\n"
                                "    }\n"
                                "\n"
                                "    // we have some solutions in edge2\n"
                                "    if (tmp_ >= 0.0) {\n"
                                "        solutions[id - (startIDNode)] *= tmp_;\n"
                                "    }\n"
                                "\n"
                                "    if (solutions[id - (startIDNode)] > 0) {\n"
                                "        *sols = 1;\n"
                                "    }\n"
                                "}\n"
                                "\n"
                                "/**\n"
                                " * Operation to solve a Introduce node in the decomposition.\n"
                                " *\n"
                                " * @param clauses\n"
                                " *      array containing the clauses in the sat formula\n"
                                " * @param numVarsC\n"
                                " *      array containing the number of variables for each clause\n"
                                " * @param numclauses\n"
                                " *      the number of clauses\n"
                                " * @param solutions\n"
                                " *      array for saving the number of models for each assignment\n"
                                " * @param numV\n"
                                " *      the number of variables in the current bag\n"
                                " * @param edge\n"
                                " *      the number of models for each assignment of the next bag\n"
                                " * @param numVE\n"
                                " *      the number of variables in the next bag\n"
                                " * @param variables\n"
                                " *      the ids of the variables in the current bag\n"
                                " * @param edgeVariables\n"
                                " *      the ids of the variables in the next bag\n"
                                " */\n"
                                "stype solveIntroduceF(__global long *clauses, __global long *numVarsC, long numclauses, long numV, __global stype *edge, long numVE,\n"
                                "                      __global long *variables, __global long *edgeVariables, long minId, long maxId,\n"
                                "                      long startIDEdge, __global double *weights, long id) {\n"
                                "    stype tmp;\n"
                                "    if (edge != 0) {\n"
                                "        // get solutions count edge\n"
                                "        tmp = solveIntroduce_(numV, edge, numVE, variables, edgeVariables, minId, maxId, startIDEdge, weights, id);\n"
                                "    } else {\n"
                                "        // no edge - solve leaf\n"
                                "        tmp = 1.0;\n"
                                "\n"
                                "        //weighted model count\n"
                                "        if (weights != 0) {\n"
                                "            for (int i = 0; i < numV; i++) {\n"
                                "                tmp *= weights[((id >> i) & 1) > 0 ? variables[i] * 2 : variables[i] * 2 + 1];\n"
                                "            }\n"
                                "        }\n"
                                "    }\n"
                                "    if (tmp > 0.0) {\n"
                                "        // check if assignment satisfies the given clauses\n"
                                "        int sat = checkBag(clauses, numVarsC, numclauses, id, numV, variables);\n"
                                "        if (sat != 1) {\n"
                                "            return 0.0;\n"
                                "        } else {\n"
                                "            return tmp;\n"
                                "        }\n"
                                "    } else {\n"
                                "        return 0.0;\n"
                                "    }\n"
                                "}\n"
                                "\n"
                                "\n"
                                "/**\n"
                                " * Operation to solve a Forget node in the decomposition.\n"
                                " *\n"
                                " * @param solutions\n"
                                " *      array for saving the number of models for each assignment\n"
                                " * @param variablesCurrent\n"
                                " *      array containing the ids of the variables in the current bag\n"
                                " * @param edge\n"
                                " *      array containing the solutions in the last node\n"
                                " * @param numVarsEdge\n"
                                " *      number of variables in the edge bag\n"
                                " * @param variablesEdge\n"
                                " *      array containing the ids of the variables in the next bag\n"
                                " * @param combinations\n"
                                " *      the number of solutions that relate to this bag from the next bag\n"
                                " * @param numVarsCurrent\n"
                                " *      number of variables in the current bag\n"
                                " * @param clauses\n"
                                " *      array containing the clauses in the sat formula\n"
                                " * @param numVarsC\n"
                                " *      array containing the number of variables for each clause\n"
                                " * @param numclauses\n"
                                " *      the number of clauses\n"
                                " * @param solutions\n"
                                " *      array for saving the number of models for each assignment\n"
                                " * @param numV\n"
                                " *      the number of variables in the current bag\n"
                                " * @param edge\n"
                                " *      the number of models for each assignment of the next bag\n"
                                " * @param numVE\n"
                                " *      the number of variables in the next bag\n"
                                " * @param variables\n"
                                " *      the ids of the variables in the current bag\n"
                                " * @param edgeVariables\n"
                                " *      the ids of the variables in the next bag\n"
                                " */\n"
                                "__kernel void solveIntroduceForget(__global stype *solsF, __global long *varsF, __global stype *solsE,\n"
                                "                                   long numVE, __global long *varsE, long combinations, long numVF,\n"
                                "                                   long minIdE, long maxIdE, long startIDF,\n"
                                "                                   long startIDE, __global int *sols,\n"
                                "                                   long numVI, __global long *varsI,\n"
                                "                                   __global long *clauses, __global long *numVarsC, long numclauses, __global double *weights) {\n"
                                "    long id = get_global_id(0);\n"
                                "    if (numVI != numVF) {\n"
                                "        long templateId = 0;\n"
                                "        // generate templateId\n"
                                "        for (int i = 0, a = 0; i < numVI && a < numVF; i++) {\n"
                                "            if (varsI[i] == varsF[a]) {\n"
                                "                templateId = templateId | (((id >> a) & 1) << i);\n"
                                "                a++;\n"
                                "            }\n"
                                "        }\n"
                                "\n"
                                "        // iterate through all corresponding edge solutions\n"
                                "        for (int i = 0; i < combinations; i++) {\n"
                                "            long b = 0, otherId = templateId;\n"
                                "            for (int a = 0; a < numVI; a++) {\n"
                                "                if (b >= numVF || varsI[a] != varsF[b]) {\n"
                                "                    otherId = otherId | (((i >> (a - b)) & 1) << a);\n"
                                "                } else {\n"
                                "                    b++;\n"
                                "                }\n"
                                "            }\n"
                                "            // get solution count of the corresponding assignment in the edge\n"
                                "            solsF[id - (startIDF)] += solveIntroduceF(clauses, numVarsC, numclauses, numVI, solsE, numVE, varsI, varsE, minIdE, maxIdE, startIDE, weights, otherId);\n"
                                "        }\n"
                                "    } else {\n"
                                "        // no forget variables, only introduce\n"
                                "        solsF[id - (startIDF)] += solveIntroduceF(clauses, numVarsC, numclauses, numVI, solsE, numVE, varsI, varsE, minIdE, maxIdE, startIDE, weights, id);\n"
                                "    }\n"
                                "    if (solsF[id - (startIDF)] > 0) {\n"
                                "        *sols = 1;\n"
                                "    }\n"
                                "}");
#endif