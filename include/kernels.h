#ifndef GPUSAT_SAT_D_H
#define GPUSAT_SAT_D_H

#include <string>

namespace gpusat {
    const std::string DOUBLE_KERNEL_STRING(
            "#define stype double\n"
                    "\n"
                    "/**\n"
                    " *\n"
                    " * @param solutions\n"
                    " * @param numV\n"
                    " * @param edge\n"
                    " * @param numVE\n"
                    " * @param variables\n"
                    " * @param edgeVariables\n"
                    " */\n"
                    "stype\n"
                    "solveIntroduce_(long numV, __global stype *edge, long numVE, __global long *variables, __global long *edgeVariables, __global long *minId, __global\n"
                    "                long *maxId, __global long *startIDEdge) {\n"
                    "    long id = get_global_id(0);\n"
                    "    long otherId = 0;\n"
                    "    long a = 0, b = 0;\n"
                    "    for (b = 0; b < numVE && a < numV; b++) {\n"
                    "        while ((variables[a] != edgeVariables[b])) {\n"
                    "            a++;\n"
                    "        }\n"
                    "        otherId = otherId | (((id >> a) & 1) << b);\n"
                    "        a++;\n"
                    "    };\n"
                    "\n"
                    "    if (otherId >= (*minId) && otherId < (*maxId)) {\n"
                    "        return edge[otherId - (*startIDEdge)];\n"
                    "    } else {\n"
                    "        return -1.0;\n"
                    "    }\n"
                    "\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to check if an assignment satisfies the clauses of a SAT formula.\n"
                    " *\n"
                    " * @param clauses\n"
                    " *      the clauses in the SAT formula\n"
                    " * @param numVarsC\n"
                    " *      array containing the number of Variables in each clause\n"
                    " * @param numclauses\n"
                    " *      the number of clauses in the sat formula\n"
                    " * @param id\n"
                    " *      the id of the thread - used to get the variable assignment\n"
                    " * @param numV\n"
                    " *      the number of variables\n"
                    " * @param variables\n"
                    " *      a vector containing the ids of the variables\n"
                    " * @return\n"
                    " *      1 - if the assignment satisfies the formula\n"
                    " *      0 - if the assignment doesn't satisfy the formula\n"
                    " */\n"
                    "int checkBag(__global long *clauses, __global long *numVarsC, long numclauses, long id, long numV, __global long *variables) {\n"
                    "    long i, varNum = 0;\n"
                    "    long satC = 0, a, b;\n"
                    "    for (i = 0; i < numclauses; i++) {\n"
                    "        satC = 0;\n"
                    "        for (a = 0; a < numVarsC[i] && !satC; a++) {\n"
                    "            satC = 1;\n"
                    "            for (b = 0; b < numV; b++) {\n"
                    "                if ((clauses[varNum + a] == variables[b]) ||\n"
                    "                    (clauses[varNum + a] == -variables[b])) {\n"
                    "                    satC = 0;\n"
                    "                    if (clauses[varNum + a] < 0) {\n"
                    "                        if ((id & (1 << (b))) == 0) {\n"
                    "                            satC = 1;\n"
                    "                            break;\n"
                    "                        }\n"
                    "                    } else {\n"
                    "                        if ((id & (1 << (b))) > 0) {\n"
                    "                            satC = 1;\n"
                    "                            break;\n"
                    "                        }\n"
                    "                    }\n"
                    "                }\n"
                    "            }\n"
                    "        }\n"
                    "        varNum += numVarsC[i];\n"
                    "        if (!satC) {\n"
                    "            return 0;\n"
                    "        }\n"
                    "    }\n"
                    "    return 1;\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to solve a Join node in the decomposition.\n"
                    " *\n"
                    " * @param solutions\n"
                    " *      array to save the number of solutions of the join\n"
                    " * @param edge1\n"
                    " *      array containing the number of solutions in the first edge\n"
                    " * @param edge2\n"
                    " *      array containing the number of solutions in the second edge\n"
                    " * @param variables\n"
                    " *      the variables in the join bag\n"
                    " * @param edgeVariables1\n"
                    " *      the variables in the bag of the first edge\n"
                    " * @param edgeVariables2\n"
                    " *      the variables in the bag of the second edge\n"
                    " * @param numV\n"
                    " *      the number of variables in the join bag\n"
                    " * @param numVE1\n"
                    " *      the number of variables in the first edge\n"
                    " * @param numVE2\n"
                    " *      the number of variables in the second edge\n"
                    " */\n"
                    "__kernel void\n"
                    "solveJoin(__global stype *solutions, __global stype *edge1, __global stype *edge2, __global long *variables, __global long *edgeVariables1, __global\n"
                    "          long *edgeVariables2, long numV, long numVE1, long numVE2, __global long *minId1, __global long *maxId1, __global long *minId2, __global\n"
                    "          long *maxId2, __global long *startIDNode, __global long *startIDEdge1, __global long *startIDEdge2) {\n"
                    "    long id = get_global_id(0);\n"
                    "    stype tmp, tmp_;\n"
                    "    tmp = solveIntroduce_(numV, edge1, numVE1, variables, edgeVariables1, minId1, maxId1, startIDEdge1);\n"
                    "    tmp_ = solveIntroduce_(numV, edge2, numVE2, variables, edgeVariables2, minId2, maxId2, startIDEdge2);\n"
                    "    if (tmp >= 0.0) {\n"
                    "        solutions[id - (*startIDNode)] *= tmp;\n"
                    "    }\n"
                    "    if (tmp_ >= 0.0) {\n"
                    "        solutions[id - (*startIDNode)] *= tmp_;\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to solve a Forget node in the decomposition.\n"
                    " *\n"
                    " * @param solutions\n"
                    " *      array for saving the number of models for each assignment\n"
                    " * @param variablesCurrent\n"
                    " *      array containing the ids of the variables in the current bag\n"
                    " * @param edge\n"
                    " *      array containing the solutions in the last node\n"
                    " * @param numVarsEdge\n"
                    " *      number of variables in the edge bag\n"
                    " * @param variablesEdge\n"
                    " *      array containing the ids of the variables in the next bag\n"
                    " * @param combinations\n"
                    " *      the number of solutions that relate to this bag from the next bag\n"
                    " * @param numVarsCurrent\n"
                    " *      number of variables in the current bag\n"
                    " */\n"
                    "__kernel void\n"
                    "solveForget(__global stype *solutions, __global long *variablesCurrent, __global stype *edge, long numVarsEdge, __global long *variablesEdge,\n"
                    "            long combinations, long numVarsCurrent, __global long *minId, __global long *maxId, __global long *startIDNode, __global\n"
                    "            long *startIDEdge) {\n"
                    "    long id = get_global_id(0), i = 0, a = 0, templateId = 0, test = 0;\n"
                    "    for (i = 0; i < numVarsEdge && a < numVarsCurrent; i++) {\n"
                    "        if (variablesEdge[i] == variablesCurrent[a]) {\n"
                    "            templateId = templateId | (((id >> a) & 1) << i);\n"
                    "            a++;\n"
                    "        }\n"
                    "    }\n"
                    "    stype tmp, tmp_;\n"
                    "    for (i = 0; i < combinations; i++) {\n"
                    "        long b = 0, otherId = templateId;\n"
                    "        for (a = 0; a < numVarsEdge; a++) {\n"
                    "            if (b >= numVarsCurrent || variablesEdge[a] != variablesCurrent[b]) {\n"
                    "                otherId = otherId | (((i >> (a - b)) & 1) << a);\n"
                    "            } else {\n"
                    "                b++;\n"
                    "            }\n"
                    "        }\n"
                    "        if (otherId >= (*minId) && otherId < (*maxId)) {\n"
                    "            solutions[id - (*startIDNode)] += edge[otherId - (*startIDEdge)];\n"
                    "        }\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to solve a Leaf node in the decomposition.\n"
                    " *\n"
                    " * @param clauses\n"
                    " *      array containing the clauses of the sat formula\n"
                    " * @param numVarsC\n"
                    " *      array containing the number of variables for each clause\n"
                    " * @param numclauses\n"
                    " *      number of clauses in the sat formula\n"
                    " * @param solutions\n"
                    " *      array for saving the number of models for each assignment\n"
                    " * @param numV\n"
                    " *      number of variables in the bag\n"
                    " * @param variables\n"
                    " *      array containing the ids of the variables in the bag\n"
                    " */\n"
                    "__kernel void\n"
                    "solveLeaf(__global long *clauses, __global long *numVarsC, long numclauses, __global stype *solutions, long numV, __global long *variables, __global\n"
                    "          long *models, __global long *startID) {\n"
                    "    long id = get_global_id(0);\n"
                    "    int sat = checkBag(clauses, numVarsC, numclauses, id, numV, variables);\n"
                    "    if (sat == 1) {\n"
                    "        (*models) = 1;\n"
                    "        solutions[id - (*startID)] = 1.0;\n"
                    "    } else {\n"
                    "        solutions[id - (*startID)] = 0.0;\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to solve a Introduce node in the decomposition.\n"
                    " *\n"
                    " * @param clauses\n"
                    " *      array containing the clauses in the sat formula\n"
                    " * @param numVarsC\n"
                    " *      array containing the number of variables for each clause\n"
                    " * @param numclauses\n"
                    " *      the number of clauses\n"
                    " * @param solutions\n"
                    " *      array for saving the number of models for each assignment\n"
                    " * @param numV\n"
                    " *      the number of variables in the current bag\n"
                    " * @param edge\n"
                    " *      the number of models for each assignment of the next bag\n"
                    " * @param numVE\n"
                    " *      the number of variables in the next bag\n"
                    " * @param variables\n"
                    " *      the ids of the variables in the current bag\n"
                    " * @param edgeVariables\n"
                    " *      the ids of the variables in the next bag\n"
                    " */\n"
                    "__kernel void\n"
                    "solveIntroduce(__global long *clauses, __global long *numVarsC, long numclauses, __global stype *solutions, long numV, __global stype *edge,\n"
                    "               long numVE, __global long *variables, __global long *edgeVariables, __global long *models, __global long *minId, __global long *maxId,\n"
                    "               __global long *startIDNode, __global long *startIDEdge) {\n"
                    "    long id = get_global_id(0);\n"
                    "    stype tmp;\n"
                    "    tmp = solveIntroduce_(numV, edge, numVE, variables, edgeVariables, minId, maxId, startIDEdge);\n"
                    "    if (tmp > 0.0) {\n"
                    "        int sat = checkBag(clauses, numVarsC, numclauses, id, numV, variables);\n"
                    "        if (sat != 1) {\n"
                    "            solutions[id - (*startIDNode)] = 0.0;\n"
                    "        } else {\n"
                    "            (*models) = 1;\n"
                    "            solutions[id - (*startIDNode)] = tmp;\n"
                    "        }\n"
                    "    } else if (tmp == 0.0) {\n"
                    "        solutions[id - (*startIDNode)] = 0.0;\n"
                    "    }\n"
                    "}");
    const std::string D4_KERNEL_STRING(
            "#define stype double\n"
                    "\n"
                    "typedef struct {\n"
                    "    stype x[4];\n"
                    "} d4_Type;\n"
                    "\n"
                    "void d4_mul(d4_Type *a, __global d4_Type *b, __global d4_Type *ret);\n"
                    "\n"
                    "void d4_add(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                    "\n"
                    "void d4_div(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                    "\n"
                    "void d4_assign(d4_Type *a, d4_Type *b);\n"
                    "\n"
                    "void new_d4(stype d, stype d1, stype d2, stype d3, d4_Type *ret);\n"
                    "\n"
                    "/**\n"
                    " *\n"
                    " * @param solutions\n"
                    " * @param numV\n"
                    " * @param edge\n"
                    " * @param numVE\n"
                    " * @param variables\n"
                    " * @param edgeVariables\n"
                    " */\n"
                    "void solveIntroduce_(long numV, __global d4_Type *edge, long numVE, __global long *variables, __global long *edgeVariables, d4_Type *ret, __global\n"
                    "                     long *minId, __global long *maxId, __global long *startIDEdge) {\n"
                    "    long id = get_global_id(0);\n"
                    "    long otherId = 0;\n"
                    "    long a = 0, b = 0;\n"
                    "    for (b = 0; b < numVE && a < numV; b++) {\n"
                    "        while ((variables[a] != edgeVariables[b])) {\n"
                    "            a++;\n"
                    "        }\n"
                    "        otherId = otherId | (((id >> a) & 1) << b);\n"
                    "        a++;\n"
                    "    };\n"
                    "\n"
                    "    if (otherId >= (*minId) && otherId < (*maxId)) {\n"
                    "        ret->x[0] = edge[otherId - (*startIDEdge)].x[0];\n"
                    "        ret->x[1] = edge[otherId - (*startIDEdge)].x[1];\n"
                    "        ret->x[2] = edge[otherId - (*startIDEdge)].x[2];\n"
                    "        ret->x[3] = edge[otherId - (*startIDEdge)].x[3];\n"
                    "    } else {\n"
                    "        ret->x[0] = -1.0;\n"
                    "        ret->x[1] = 0.0;\n"
                    "        ret->x[2] = 0.0;\n"
                    "        ret->x[3] = 0.0;\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to check if an assignment satisfies the clauses of a SAT formula.\n"
                    " *\n"
                    " * @param clauses\n"
                    " *      the clauses in the SAT formula\n"
                    " * @param numVarsC\n"
                    " *      array containing the number of Variables in each clause\n"
                    " * @param numclauses\n"
                    " *      the number of clauses in the sat formula\n"
                    " * @param id\n"
                    " *      the id of the thread - used to get the variable assignment\n"
                    " * @param numV\n"
                    " *      the number of variables\n"
                    " * @param variables\n"
                    " *      a vector containing the ids of the variables\n"
                    " * @return\n"
                    " *      1 - if the assignment satisfies the formula\n"
                    " *      0 - if the assignment doesn't satisfy the formula\n"
                    " */\n"
                    "int checkBag(__global long *clauses, __global long *numVarsC, long numclauses, long id, long numV, __global long *variables) {\n"
                    "    long i, varNum = 0;\n"
                    "    long satC = 0, a, b;\n"
                    "    for (i = 0; i < numclauses; i++) {\n"
                    "        satC = 0;\n"
                    "        for (a = 0; a < numVarsC[i] && !satC; a++) {\n"
                    "            satC = 1;\n"
                    "            for (b = 0; b < numV; b++) {\n"
                    "                if ((clauses[varNum + a] == variables[b]) ||\n"
                    "                    (clauses[varNum + a] == -variables[b])) {\n"
                    "                    satC = 0;\n"
                    "                    if (clauses[varNum + a] < 0) {\n"
                    "                        if ((id & (1 << (b))) == 0) {\n"
                    "                            satC = 1;\n"
                    "                            break;\n"
                    "                        }\n"
                    "                    } else {\n"
                    "                        if ((id & (1 << (b))) > 0) {\n"
                    "                            satC = 1;\n"
                    "                            break;\n"
                    "                        }\n"
                    "                    }\n"
                    "                }\n"
                    "            }\n"
                    "        }\n"
                    "        varNum += numVarsC[i];\n"
                    "        if (!satC) {\n"
                    "            return 0;\n"
                    "        }\n"
                    "    }\n"
                    "    return 1;\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to solve a Join node in the decomposition.\n"
                    " *\n"
                    " * @param solutions\n"
                    " *      array to save the number of solutions of the join\n"
                    " * @param edge1\n"
                    " *      array containing the number of solutions in the first edge\n"
                    " * @param edge2\n"
                    " *      array containing the number of solutions in the second edge\n"
                    " * @param variables\n"
                    " *      the variables in the join bag\n"
                    " * @param edgeVariables1\n"
                    " *      the variables in the bag of the first edge\n"
                    " * @param edgeVariables2\n"
                    " *      the variables in the bag of the second edge\n"
                    " * @param numV\n"
                    " *      the number of variables in the join bag\n"
                    " * @param numVE1\n"
                    " *      the number of variables in the first edge\n"
                    " * @param numVE2\n"
                    " *      the number of variables in the second edge\n"
                    " */\n"
                    "__kernel void\n"
                    "solveJoin(__global d4_Type *solutions, __global d4_Type *edge1, __global d4_Type *edge2, __global long *variables, __global long *edgeVariables1,\n"
                    "          __global long *edgeVariables2, long numV, long numVE1, long numVE2, __global long *minId1, __global long *maxId1, __global long *minId2,\n"
                    "          __global long *maxId2, __global long *startIDNode, __global long *startIDEdge1, __global long *startIDEdge2) {\n"
                    "    long id = get_global_id(0);\n"
                    "    d4_Type tmp, tmp_;\n"
                    "    solveIntroduce_(numV, edge1, numVE1, variables, edgeVariables1, &tmp, minId1, maxId1, startIDEdge1);\n"
                    "    solveIntroduce_(numV, edge2, numVE2, variables, edgeVariables2, &tmp_, minId2, maxId2, startIDEdge2);\n"
                    "    if (tmp.x[0] >= 0.0) {\n"
                    "        d4_mul(&tmp, &solutions[id - (*startIDNode)], &solutions[id - (*startIDNode)]);\n"
                    "    }\n"
                    "\n"
                    "    if (tmp_.x[0] >= 0.0) {\n"
                    "        d4_mul(&tmp_, &solutions[id - (*startIDNode)], &solutions[id - (*startIDNode)]);\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to solve a Forget node in the decomposition.\n"
                    " *\n"
                    " * @param solutions\n"
                    " *      array for saving the number of models for each assignment\n"
                    " * @param variablesCurrent\n"
                    " *      array containing the ids of the variables in the current bag\n"
                    " * @param edge\n"
                    " *      array containing the solutions in the last node\n"
                    " * @param numVarsEdge\n"
                    " *      number of variables in the edge bag\n"
                    " * @param variablesEdge\n"
                    " *      array containing the ids of the variables in the next bag\n"
                    " * @param combinations\n"
                    " *      the number of solutions that relate to this bag from the next bag\n"
                    " * @param numVarsCurrent\n"
                    " *      number of variables in the current bag\n"
                    " */\n"
                    "__kernel void\n"
                    "solveForget(__global d4_Type *solutions, __global long *variablesCurrent, __global d4_Type *edge, long numVarsEdge, __global long *variablesEdge,\n"
                    "            long combinations, long numVarsCurrent, __global long *minId, __global long *maxId, __global long *startIDNode, __global\n"
                    "            long *startIDEdge) {\n"
                    "    long id = get_global_id(0), i = 0, a = 0, templateId = 0, test = 0;\n"
                    "    for (i = 0; i < numVarsEdge && a < numVarsCurrent; i++) {\n"
                    "        if (variablesEdge[i] == variablesCurrent[a]) {\n"
                    "            templateId = templateId | (((id >> a) & 1) << i);\n"
                    "            a++;\n"
                    "        }\n"
                    "    }\n"
                    "    d4_Type tmp, tmp_;\n"
                    "    for (i = 0; i < combinations; i++) {\n"
                    "        long b = 0, otherId = templateId;\n"
                    "        for (a = 0; a < numVarsEdge; a++) {\n"
                    "            if (b >= numVarsCurrent || variablesEdge[a] != variablesCurrent[b]) {\n"
                    "                otherId = otherId | (((i >> (a - b)) & 1) << a);\n"
                    "            } else {\n"
                    "                b++;\n"
                    "            }\n"
                    "        }\n"
                    "        if (otherId >= (*minId) && otherId < (*maxId)) {\n"
                    "            tmp.x[0] = solutions[id - (*startIDNode)].x[0];\n"
                    "            tmp.x[1] = solutions[id - (*startIDNode)].x[1];\n"
                    "            tmp.x[2] = solutions[id - (*startIDNode)].x[2];\n"
                    "            tmp.x[3] = solutions[id - (*startIDNode)].x[3];\n"
                    "\n"
                    "            tmp_.x[0] = edge[otherId - (*startIDEdge)].x[0];\n"
                    "            tmp_.x[1] = edge[otherId - (*startIDEdge)].x[1];\n"
                    "            tmp_.x[2] = edge[otherId - (*startIDEdge)].x[2];\n"
                    "            tmp_.x[3] = edge[otherId - (*startIDEdge)].x[3];\n"
                    "\n"
                    "            d4_add(&tmp, &tmp_, &tmp);\n"
                    "\n"
                    "            solutions[id - (*startIDNode)].x[0] = tmp.x[0];\n"
                    "            solutions[id - (*startIDNode)].x[1] = tmp.x[1];\n"
                    "            solutions[id - (*startIDNode)].x[2] = tmp.x[2];\n"
                    "            solutions[id - (*startIDNode)].x[3] = tmp.x[3];\n"
                    "        }\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to solve a Leaf node in the decomposition.\n"
                    " *\n"
                    " * @param clauses\n"
                    " *      array containing the clauses of the sat formula\n"
                    " * @param numVarsC\n"
                    " *      array containing the number of variables for each clause\n"
                    " * @param numclauses\n"
                    " *      number of clauses in the sat formula\n"
                    " * @param solutions\n"
                    " *      array for saving the number of models for each assignment\n"
                    " * @param numV\n"
                    " *      number of variables in the bag\n"
                    " * @param variables\n"
                    " *      array containing the ids of the variables in the bag\n"
                    " */\n"
                    "__kernel void\n"
                    "solveLeaf(__global long *clauses, __global long *numVarsC, long numclauses, __global d4_Type *solutions, long numV, __global long *variables, __global\n"
                    "          long *models, __global long *startID) {\n"
                    "    long id = get_global_id(0);\n"
                    "    int sat = checkBag(clauses, numVarsC, numclauses, id, numV, variables);\n"
                    "    if (sat == 1) {\n"
                    "        (*models) = 1;\n"
                    "        solutions[id - (*startID)].x[0] = 1.0;\n"
                    "        solutions[id - (*startID)].x[1] = 0.0;\n"
                    "        solutions[id - (*startID)].x[2] = 0.0;\n"
                    "        solutions[id - (*startID)].x[3] = 0.0;\n"
                    "    } else {\n"
                    "        solutions[id - (*startID)].x[0] = 0.0;\n"
                    "        solutions[id - (*startID)].x[1] = 0.0;\n"
                    "        solutions[id - (*startID)].x[2] = 0.0;\n"
                    "        solutions[id - (*startID)].x[3] = 0.0;\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "/**\n"
                    " * Operation to solve a Introduce node in the decomposition.\n"
                    " *\n"
                    " * @param clauses\n"
                    " *      array containing the clauses in the sat formula\n"
                    " * @param numVarsC\n"
                    " *      array containing the number of variables for each clause\n"
                    " * @param numclauses\n"
                    " *      the number of clauses\n"
                    " * @param solutions\n"
                    " *      array for saving the number of models for each assignment\n"
                    " * @param numV\n"
                    " *      the number of variables in the current bag\n"
                    " * @param edge\n"
                    " *      the number of models for each assignment of the next bag\n"
                    " * @param numVE\n"
                    " *      the number of variables in the next bag\n"
                    " * @param variables\n"
                    " *      the ids of the variables in the current bag\n"
                    " * @param edgeVariables\n"
                    " *      the ids of the variables in the next bag\n"
                    " */\n"
                    "__kernel void\n"
                    "solveIntroduce(__global long *clauses, __global long *numVarsC, long numclauses, __global d4_Type *solutions, long numV, __global d4_Type *edge,\n"
                    "               long numVE, __global long *variables, __global long *edgeVariables, __global long *models, __global long *minId, __global long *maxId,\n"
                    "               __global long *startIDNode, __global long *startIDEdge) {\n"
                    "    long id = get_global_id(0);\n"
                    "    d4_Type tmp;\n"
                    "    solveIntroduce_(numV, edge, numVE, variables, edgeVariables, &tmp, minId, maxId, startIDEdge);\n"
                    "    if (tmp.x[0] > 0.0) {\n"
                    "        int sat = checkBag(clauses, numVarsC, numclauses, id, numV, variables);\n"
                    "        if (sat != 1) {\n"
                    "            solutions[id - (*startIDNode)].x[0] = 0.0;\n"
                    "            solutions[id - (*startIDNode)].x[1] = 0.0;\n"
                    "            solutions[id - (*startIDNode)].x[2] = 0.0;\n"
                    "            solutions[id - (*startIDNode)].x[3] = 0.0;\n"
                    "        } else {\n"
                    "            (*models) = 1;\n"
                    "            solutions[id - (*startIDNode)].x[0] = tmp.x[0];\n"
                    "            solutions[id - (*startIDNode)].x[1] = tmp.x[1];\n"
                    "            solutions[id - (*startIDNode)].x[2] = tmp.x[2];\n"
                    "            solutions[id - (*startIDNode)].x[3] = tmp.x[3];\n"
                    "        }\n"
                    "    } else if (tmp.x[0] == 0.0) {\n"
                    "        solutions[id - (*startIDNode)].x[0] = 0.0;\n"
                    "        solutions[id - (*startIDNode)].x[1] = 0.0;\n"
                    "        solutions[id - (*startIDNode)].x[2] = 0.0;\n"
                    "        solutions[id - (*startIDNode)].x[3] = 0.0;\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "\n"
                    "/**\n"
                    " * adaptation of https://github.com/scibuilder/QD for opencl\n"
                    " */\n"
                    "\n"
                    "///headers\n"
                    "#define _QD_SPLITTER 134217729.0 // = 2^27 + 1\n"
                    "#define _QD_SPLIT_THRESH 6.69692879491417e+299 // = 2^996\n"
                    "\n"
                    "void to_d4(stype x, d4_Type *ret);\n"
                    "\n"
                    "void d4_neg(d4_Type *x, d4_Type *ret);\n"
                    "\n"
                    "void d4_minus(d4_Type *a, d4_Type *b, d4_Type *ret);\n"
                    "\n"
                    "void d4_log(d4_Type *a, d4_Type *ret);\n"
                    "\n"
                    "stype d4_quick_two_sum(stype a, stype b, stype *err);\n"
                    "\n"
                    "stype d4_two_sum(stype a, stype b, stype *err);\n"
                    "\n"
                    "stype d4_quick_three_accum(stype *a, stype *b, stype c);\n"
                    "\n"
                    "void d4_renorm(stype *c0, stype *c1, stype *c2, stype *c3);\n"
                    "\n"
                    "void d4_split(stype a, stype *hi, stype *lo);\n"
                    "\n"
                    "stype d4_two_prod(stype a, stype b, stype *err);\n"
                    "\n"
                    "void d4_three_sum(stype *a, stype *b, stype *c);\n"
                    "\n"
                    "void d4_renorm_(stype *c0, stype *c1, stype *c2, stype *c3, stype *c4);\n"
                    "\n"
                    "void d4_three_sum2(stype *a, stype *b, stype *c);;\n"
                    "\n"
                    "void d4_mul_qd_d(d4_Type *a, stype b, d4_Type *ret);\n"
                    "\n"
                    "void d4_ldexp(d4_Type *a, int n, d4_Type *ret);\n"
                    "\n"
                    "bool d4_is_zero(d4_Type *x);\n"
                    "\n"
                    "bool d4_is_one(d4_Type *x);\n"
                    "\n"
                    "void d4_mul_pwr2(d4_Type *a, stype b, d4_Type *ret);\n"
                    "\n"
                    "void d4_sqr(d4_Type *a, d4_Type *ret);\n"
                    "\n"
                    "void d4_pow(d4_Type *a, int n, d4_Type *ret);\n"
                    "\n"
                    "bool d4_l(d4_Type *a, d4_Type *b) {\n"
                    "    return (a->x[0] < b->x[0] ||\n"
                    "            (a->x[0] == b->x[0] && (a->x[1] < b->x[1]\n"
                    "                                    || (a->x[1] == b->x[1] && (a->x[2] < b->x[2]\n"
                    "                                                               ||\n"
                    "                                                               (a->x[2] == b->x[2] && a->x[3] < b->x[3]))))));\n"
                    "}\n"
                    "\n"
                    "///implementation\n"
                    "void to_d4(stype x, d4_Type *ret) {\n"
                    "    ret->x[0] = x;\n"
                    "    ret->x[1] = 0.0;\n"
                    "    ret->x[2] = 0.0;\n"
                    "    ret->x[3] = 0.0;\n"
                    "}\n"
                    "\n"
                    "void d4_neg(d4_Type *x, d4_Type *ret) {\n"
                    "    ret->x[0] = -x->x[0];\n"
                    "    ret->x[1] = -x->x[1];\n"
                    "    ret->x[2] = -x->x[2];\n"
                    "    ret->x[3] = -x->x[3];\n"
                    "}\n"
                    "\n"
                    "void new_d4(stype d, stype d1, stype d2, stype d3, d4_Type *ret) {\n"
                    "    ret->x[0] = d;\n"
                    "    ret->x[1] = d1;\n"
                    "    ret->x[2] = d2;\n"
                    "    ret->x[3] = d3;\n"
                    "}\n"
                    "\n"
                    "stype d4_quick_two_sum(stype a, stype b, stype *err) {\n"
                    "    stype s = a + b;\n"
                    "    (*err) = b - (s - a);\n"
                    "    return s;\n"
                    "}\n"
                    "\n"
                    "stype d4_two_sum(stype a, stype b, stype *err) {\n"
                    "    stype s = a + b;\n"
                    "    stype bb = s - a;\n"
                    "    (*err) = (a - (s - bb)) + (b - bb);\n"
                    "    return s;\n"
                    "}\n"
                    "\n"
                    "stype d4_quick_three_accum(stype *a, stype *b, stype c) {\n"
                    "    stype s;\n"
                    "    bool za, zb;\n"
                    "\n"
                    "    s = d4_two_sum((*b), c, b);\n"
                    "    s = d4_two_sum((*a), s, a);\n"
                    "\n"
                    "    za = ((*a) != 0.0);\n"
                    "    zb = ((*b) != 0.0);\n"
                    "\n"
                    "    if (za && zb)\n"
                    "        return s;\n"
                    "\n"
                    "    if (!zb) {\n"
                    "        (*b) = (*a);\n"
                    "        (*a) = s;\n"
                    "    } else {\n"
                    "        (*a) = s;\n"
                    "    }\n"
                    "\n"
                    "    return 0.0;\n"
                    "}\n"
                    "\n"
                    "void d4_renorm(stype *c0, stype *c1, stype *c2, stype *c3) {\n"
                    "    stype s0, s1, s2 = 0.0, s3 = 0.0;\n"
                    "\n"
                    "    if (isinf((*c0))) return;\n"
                    "\n"
                    "    s0 = d4_quick_two_sum((*c2), (*c3), c3);\n"
                    "    s0 = d4_quick_two_sum((*c1), s0, c2);\n"
                    "    (*c0) = d4_quick_two_sum((*c0), s0, c1);\n"
                    "\n"
                    "    s0 = (*c0);\n"
                    "    s1 = (*c1);\n"
                    "    if (s1 != 0.0) {\n"
                    "        s1 = d4_quick_two_sum(s1, (*c2), &s2);\n"
                    "        if (s2 != 0.0)\n"
                    "            s2 = d4_quick_two_sum(s2, (*c3), &s3);\n"
                    "        else\n"
                    "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                    "    } else {\n"
                    "        s0 = d4_quick_two_sum(s0, (*c2), &s1);\n"
                    "        if (s1 != 0.0)\n"
                    "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                    "        else\n"
                    "            s0 = d4_quick_two_sum(s0, (*c3), &s1);\n"
                    "    }\n"
                    "\n"
                    "    (*c0) = s0;\n"
                    "    (*c1) = s1;\n"
                    "    (*c2) = s2;\n"
                    "    (*c3) = s3;\n"
                    "}\n"
                    "\n"
                    "void d4_add(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                    "    int i, j, k;\n"
                    "    stype s, t;\n"
                    "    stype u, v;\n"
                    "    d4_Type x;\n"
                    "    to_d4(0.0, &x);\n"
                    "\n"
                    "    i = j = k = 0;\n"
                    "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                    "        u = a->x[i++];\n"
                    "    else\n"
                    "        u = b->x[j++];\n"
                    "    if (fabs(a->x[i]) > fabs(b->x[j]))\n"
                    "        v = a->x[i++];\n"
                    "    else\n"
                    "        v = b->x[j++];\n"
                    "\n"
                    "    u = d4_quick_two_sum(u, v, &v);\n"
                    "\n"
                    "    while (k < 4) {\n"
                    "        if (i >= 4 && j >= 4) {\n"
                    "            x.x[k] = u;\n"
                    "            if (k < 3)\n"
                    "                x.x[++k] = v;\n"
                    "            break;\n"
                    "        }\n"
                    "\n"
                    "        if (i >= 4)\n"
                    "            t = b->x[j++];\n"
                    "        else if (j >= 4)\n"
                    "            t = a->x[i++];\n"
                    "        else if (fabs(a->x[i]) > fabs(b->x[j])) {\n"
                    "            t = a->x[i++];\n"
                    "        } else\n"
                    "            t = b->x[j++];\n"
                    "\n"
                    "        s = d4_quick_three_accum(&u, &v, t);\n"
                    "\n"
                    "        if (s != 0.0) {\n"
                    "            x.x[k++] = s;\n"
                    "        }\n"
                    "    }\n"
                    "\n"
                    "    for (k = i; k < 4; k++)\n"
                    "        x.x[3] += a->x[k];\n"
                    "    for (k = j; k < 4; k++)\n"
                    "        x.x[3] += b->x[k];\n"
                    "\n"
                    "    d4_renorm(&x.x[0], &x.x[1], &x.x[2], &x.x[3]);\n"
                    "    d4_assign(ret, &x);\n"
                    "}\n"
                    "\n"
                    "void d4_split(stype a, stype *hi, stype *lo) {\n"
                    "    stype temp;\n"
                    "    if (a > _QD_SPLIT_THRESH || a < -_QD_SPLIT_THRESH) {\n"
                    "        a *= 3.7252902984619140625e-09; // 2^-28\n"
                    "        temp = _QD_SPLITTER * a;\n"
                    "        (*hi) = temp - (temp - a);\n"
                    "        (*lo) = a - (*hi);\n"
                    "        (*hi) *= 268435456.0;\n"
                    "        (*lo) *= 268435456.0;\n"
                    "    } else {\n"
                    "        temp = _QD_SPLITTER * a;\n"
                    "        (*hi) = temp - (temp - a);\n"
                    "        (*lo) = a - (*hi);\n"
                    "    }\n"
                    "}\n"
                    "\n"
                    "stype d4_two_prod(stype a, stype b, stype *err) {\n"
                    "    stype a_hi, a_lo, b_hi, b_lo;\n"
                    "    stype p = a * b;\n"
                    "    d4_split(a, &a_hi, &a_lo);\n"
                    "    d4_split(b, &b_hi, &b_lo);\n"
                    "    (*err) = ((a_hi * b_hi - p) + a_hi * b_lo + a_lo * b_hi) + a_lo * b_lo;\n"
                    "    return p;\n"
                    "}\n"
                    "\n"
                    "void d4_three_sum(stype *a, stype *b, stype *c) {\n"
                    "    stype t1, t2, t3;\n"
                    "    t1 = d4_two_sum((*a), (*b), &t2);\n"
                    "    (*a) = d4_two_sum((*c), t1, &t3);\n"
                    "    (*b) = d4_two_sum(t2, t3, c);\n"
                    "}\n"
                    "\n"
                    "void d4_renorm_(stype *c0, stype *c1, stype *c2, stype *c3, stype *c4) {\n"
                    "    stype s0, s1, s2 = 0.0, s3 = 0.0;\n"
                    "\n"
                    "    if (isinf((*c0))) return;\n"
                    "\n"
                    "    s0 = d4_quick_two_sum((*c3), (*c4), c4);\n"
                    "    s0 = d4_quick_two_sum((*c2), s0, c3);\n"
                    "    s0 = d4_quick_two_sum((*c1), s0, c2);\n"
                    "    (*c0) = d4_quick_two_sum((*c0), s0, c1);\n"
                    "\n"
                    "    s0 = (*c0);\n"
                    "    s1 = (*c1);\n"
                    "\n"
                    "    s0 = d4_quick_two_sum((*c0), (*c1), &s1);\n"
                    "    if (s1 != 0.0) {\n"
                    "        s1 = d4_quick_two_sum(s1, (*c2), &s2);\n"
                    "        if (s2 != 0.0) {\n"
                    "            s2 = d4_quick_two_sum(s2, (*c3), &s3);\n"
                    "            if (s3 != 0.0)\n"
                    "                s3 += (*c4);\n"
                    "            else\n"
                    "                s2 += (*c4);\n"
                    "        } else {\n"
                    "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                    "            if (s2 != 0.0)\n"
                    "                s2 = d4_quick_two_sum(s2, (*c4), &s3);\n"
                    "            else\n"
                    "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                    "        }\n"
                    "    } else {\n"
                    "        s0 = d4_quick_two_sum(s0, (*c2), &s1);\n"
                    "        if (s1 != 0.0) {\n"
                    "            s1 = d4_quick_two_sum(s1, (*c3), &s2);\n"
                    "            if (s2 != 0.0)\n"
                    "                s2 = d4_quick_two_sum(s2, (*c4), &s3);\n"
                    "            else\n"
                    "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                    "        } else {\n"
                    "            s0 = d4_quick_two_sum(s0, (*c3), &s1);\n"
                    "            if (s1 != 0.0)\n"
                    "                s1 = d4_quick_two_sum(s1, (*c4), &s2);\n"
                    "            else\n"
                    "                s0 = d4_quick_two_sum(s0, (*c4), &s1);\n"
                    "        }\n"
                    "    }\n"
                    "\n"
                    "    (*c0) = s0;\n"
                    "    (*c1) = s1;\n"
                    "    (*c2) = s2;\n"
                    "    (*c3) = s3;\n"
                    "}\n"
                    "\n"
                    "void d4_mul(d4_Type *a, __global d4_Type *b, __global d4_Type *ret) {\n"
                    "    stype p0, p1, p2, p3, p4, p5;\n"
                    "    stype q0, q1, q2, q3, q4, q5;\n"
                    "    stype p6, p7, p8, p9;\n"
                    "    stype q6, q7, q8, q9;\n"
                    "    stype r0, r1;\n"
                    "    stype t0, t1;\n"
                    "    stype s0, s1, s2;\n"
                    "\n"
                    "    p0 = d4_two_prod(a->x[0], b->x[0], &q0);\n"
                    "\n"
                    "    p1 = d4_two_prod(a->x[0], b->x[1], &q1);\n"
                    "    p2 = d4_two_prod(a->x[1], b->x[0], &q2);\n"
                    "\n"
                    "    p3 = d4_two_prod(a->x[0], b->x[2], &q3);\n"
                    "    p4 = d4_two_prod(a->x[1], b->x[1], &q4);\n"
                    "    p5 = d4_two_prod(a->x[2], b->x[0], &q5);\n"
                    "\n"
                    "    d4_three_sum(&p1, &p2, &q0);\n"
                    "\n"
                    "    d4_three_sum(&p2, &q1, &q2);\n"
                    "    d4_three_sum(&p3, &p4, &p5);\n"
                    "\n"
                    "    s0 = d4_two_sum(p2, p3, &t0);\n"
                    "    s1 = d4_two_sum(q1, p4, &t1);\n"
                    "    s2 = q2 + p5;\n"
                    "    s1 = d4_two_sum(s1, t0, &t0);\n"
                    "    s2 += (t0 + t1);\n"
                    "\n"
                    "    p6 = d4_two_prod(a->x[0], b->x[3], &q6);\n"
                    "    p7 = d4_two_prod(a->x[1], b->x[2], &q7);\n"
                    "    p8 = d4_two_prod(a->x[2], b->x[1], &q8);\n"
                    "    p9 = d4_two_prod(a->x[3], b->x[0], &q9);\n"
                    "\n"
                    "    q0 = d4_two_sum(q0, q3, &q3);\n"
                    "    q4 = d4_two_sum(q4, q5, &q5);\n"
                    "    p6 = d4_two_sum(p6, p7, &p7);\n"
                    "    p8 = d4_two_sum(p8, p9, &p9);\n"
                    "\n"
                    "    t0 = d4_two_sum(q0, q4, &t1);\n"
                    "    t1 += (q3 + q5);\n"
                    "\n"
                    "    r0 = d4_two_sum(p6, p8, &r1);\n"
                    "    r1 += (p7 + p9);\n"
                    "\n"
                    "    q3 = d4_two_sum(t0, r0, &q4);\n"
                    "    q4 += (t1 + r1);\n"
                    "\n"
                    "    t0 = d4_two_sum(q3, s1, &t1);\n"
                    "    t1 += q4;\n"
                    "\n"
                    "    t1 += a->x[1] * b->x[3] + a->x[2] * b->x[2] + a->x[3] * b->x[1] + q6 + q7 + q8 + q9 + s2;\n"
                    "\n"
                    "    d4_renorm_(&p0, &p1, &s0, &t0, &t1);\n"
                    "    ret->x[0] = p0;\n"
                    "    ret->x[1] = p1;\n"
                    "    ret->x[2] = s0;\n"
                    "    ret->x[3] = t0;\n"
                    "}\n"
                    "\n"
                    "\n"
                    "void d4_minus(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                    "    d4_Type c;\n"
                    "    d4_neg(b, &c);\n"
                    "    d4_Type d;\n"
                    "    d4_add(a, &c, &d);\n"
                    "    d4_assign(ret, &d);\n"
                    "}\n"
                    "\n"
                    "void d4_three_sum2(stype *a, stype *b, stype *c) {\n"
                    "    stype t1, t2, t3;\n"
                    "    t1 = d4_two_sum((*a), (*b), &t2);\n"
                    "    (*a) = d4_two_sum((*c), t1, &t3);\n"
                    "    (*b) = t2 + t3;\n"
                    "}\n"
                    "\n"
                    "void d4_mul_qd_d(d4_Type *a, stype b, d4_Type *ret) {\n"
                    "    stype p0, p1, p2, p3;\n"
                    "    stype q0, q1, q2;\n"
                    "    stype s0, s1, s2, s3, s4;\n"
                    "\n"
                    "    p0 = d4_two_prod(a->x[0], b, &q0);\n"
                    "    p1 = d4_two_prod(a->x[1], b, &q1);\n"
                    "    p2 = d4_two_prod(a->x[2], b, &q2);\n"
                    "    p3 = a->x[3] * b;\n"
                    "\n"
                    "    s0 = p0;\n"
                    "\n"
                    "    s1 = d4_two_sum(q0, p1, &s2);\n"
                    "\n"
                    "    d4_three_sum(&s2, &q1, &p2);\n"
                    "\n"
                    "    d4_three_sum2(&q1, &q2, &p3);\n"
                    "    s3 = q1;\n"
                    "\n"
                    "    s4 = q2 + p2;\n"
                    "\n"
                    "    d4_renorm_(&s0, &s1, &s2, &s3, &s4);\n"
                    "    new_d4(s0, s1, s2, s3, ret);\n"
                    "}\n"
                    "\n"
                    "void d4_div(d4_Type *a, d4_Type *b, d4_Type *ret) {\n"
                    "    stype q0, q1, q2, q3;\n"
                    "\n"
                    "    d4_Type r, tmp;\n"
                    "\n"
                    "    q0 = a->x[0] / b->x[0];\n"
                    "    d4_mul_qd_d(b, q0, &tmp);\n"
                    "    d4_minus(a, &tmp, &r);\n"
                    "\n"
                    "    q1 = r.x[0] / b->x[0];\n"
                    "    d4_mul_qd_d(b, q1, &tmp);\n"
                    "    d4_minus(&r, &tmp, &r);\n"
                    "\n"
                    "    q2 = r.x[0] / b->x[0];\n"
                    "    d4_mul_qd_d(b, q2, &tmp);\n"
                    "    d4_minus(&r, &tmp, &r);\n"
                    "\n"
                    "    q3 = r.x[0] / b->x[0];\n"
                    "    d4_mul_qd_d(b, q3, &tmp);\n"
                    "    d4_minus(&r, &tmp, &r);\n"
                    "\n"
                    "    stype q4 = r.x[0] / b->x[0];\n"
                    "\n"
                    "    d4_renorm_(&q0, &q1, &q2, &q3, &q4);\n"
                    "\n"
                    "    new_d4(q0, q1, q2, q3, ret);\n"
                    "}\n"
                    "\n"
                    "void d4_assign(d4_Type *a, d4_Type *b) {\n"
                    "    a->x[0] = b->x[0];\n"
                    "    a->x[1] = b->x[1];\n"
                    "    a->x[2] = b->x[2];\n"
                    "    a->x[3] = b->x[3];\n"
                    "}");
}

#endif //GPUSAT_SAT_D_H
